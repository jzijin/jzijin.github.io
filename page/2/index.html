<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="computer science">
<meta property="og:type" content="website">
<meta property="og:title" content="SRCNN">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="SRCNN">
<meta property="og:description" content="computer science">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Z.J. Jiang">
<meta property="article:tag" content="computer science">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SRCNN</title>
  







<link rel="dns-prefetch" href="https://waline.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SRCNN</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section">归档</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section">关于</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section">分类</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section">标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Z.J. Jiang</p>
  <div class="site-description" itemprop="description">computer science</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/jzijin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jzijin" rel="noopener me" target="_blank">GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/07/computer%20science/%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Z.J. Jiang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/07/computer%20science/%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">信号安全函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-07 22:49:28" itemprop="dateCreated datePublished" datetime="2021-06-07T22:49:28+08:00">2021-06-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2021/06/07/computer%20science/%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2021/06/07/computer%20science/%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>天啊，怎么改了几行代码就改出了一个惊天大的大Bug。居然导致死锁了，这是怎么回事呢，且让我一一道来。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hxlawf/article/details/98961011">https://blog.csdn.net/hxlawf/article/details/98961011</a></p>
<!---more--->

<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>我们首先需要知道信号的概念。<strong>信号</strong>就是一条小消息，它通知进程系统中发生一个某种类型的事件。信号提供了某种机制，通知用户进程发生了某些异常。</p>
<p>信号是很短的消息，可以被发送到一个进程或一组进程。信号是事件发生时对进程的通知机制，有时也称之为软件中断。信号与硬件中断的相似之处在于打断了程序执行的正常流程，大多数情况下，无法预测信号到达的精确时间。一般来说，使用sigaction设置信号处理程序，当收到信号时，会调用信号处理器程序，可能会随时打断主程序流程；内核代表进程来调用处理器程序，当处理器返回时，主程序会在处理器打断的位置恢复执行。与 signal()相比， sigaction()系统调用在设置信号处置方面提供了更多控制，且更具灵活性。signal有可移植性的风险，尽量使用sigaction来设置信号处理程序。</p>
<p>20-1的图贴上去。<br>archlinux打印出来的kill -l打印出来的信号</p>
<ol>
<li>SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</li>
<li>SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</li>
<li>SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</li>
<li>SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</li>
<li>SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</li>
<li>SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</li>
<li>SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</li>
<li>SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</li>
<li>SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</li>
<li>SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</li>
<li>SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</li>
<li>SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</li>
<li>SIGRTMAX-1  64) SIGRTMAX</li>
</ol>
<p>1<del>31号为常规信号，同种类型的常规信号并不排队，如果一个常规信号被连续发送多次，那么，只有其中的一个发送到接收进程。。32</del>64为实时信号。实时信号与常规信号有很大不同，因为它们必须排队以便发送的多个信号都能被接收到。前者为标准信号。后者为实时信号。</p>
<p>一般而言，将信号处理函数设计得越简单越好。这将降低引发竞争条件的风险。</p>
<h1 id="信号基本概念"><a href="#信号基本概念" class="headerlink" title="信号基本概念"></a>信号基本概念</h1><h1 id="进程中使用信号"><a href="#进程中使用信号" class="headerlink" title="进程中使用信号"></a>进程中使用信号</h1><h1 id="线程中使用信号。"><a href="#线程中使用信号。" class="headerlink" title="线程中使用信号。"></a>线程中使用信号。</h1><h1 id="如何编写合适的信号处理函数"><a href="#如何编写合适的信号处理函数" class="headerlink" title="如何编写合适的信号处理函数"></a>如何编写合适的信号处理函数</h1><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>死锁风险<br>可重入性问题。</p>
<h2 id="信号术语"><a href="#信号术语" class="headerlink" title="信号术语"></a>信号术语</h2><h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><p>通过kill系统调用发送信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>pid &gt; 0，那么会发送信号给由 pid 指定的进程所属的线程组。</li>
<li>pid = 0，那么会发送信号给与调用进程同组的每个进程，包括调用进程自身。</li>
<li>pid &lt; -1，那么会向组 ID 等于该 pid 绝对值的进程组内所有下属进程发送信号。</li>
<li>pid = -1，调用进程有权将信号发往的每个目标进程，除去swapper(PID 0)，init (PID 1) 和自身进程。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span></span>;</span><br></pre></td></tr></table></figure>
<p>sigqueue系统调用可以发送实时信号。其使用方式同kill，略有不同的是，sigqueue不能通过将pid指定为负值而向整个进程组发送信号。在调用sigaction设置信号处理程序时，可以指定SA_SIGINFO标志位，就能额外收到value数据了。</p>
<h2 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h2><p>当内核把进程p从内核态切换到用户态时(例如系统调用返回，或者完成了一次上下文切换(时间片开始处))，会去检查进程p的所有未被阻塞的待处理信号。(pending &amp; ~blocked)，如果这个集合非空，那么内核选择集合中某个信号k(通常是最小的k)，并且强制p接收k。进程p收到k信号后会有如下几种方式对k信号做出应答。收到这个信号会触发某些操作。如果用sigaction注册了信号处理函数，则执行相关信号处理函数，否则执行信号的默认操作。<br>信号默认操作表。</p>
<ol>
<li>显示地忽略信号。</li>
<li>执行信号的缺省操作。由内核定义，详见表xxxx</li>
<li>通过调用相应的信号处理函数捕获信号。</li>
</ol>
<h2 id="阻塞和解除阻塞"><a href="#阻塞和解除阻塞" class="headerlink" title="阻塞和解除阻塞"></a>阻塞和解除阻塞</h2><p>内核会为每个进程维护一个信号掩码，即一组信号，并将阻塞其针对该进程的传递。如果将遭阻塞的信号发送给某进程，那么对该信号的传递将延后，直至从进程信号掩码中移除该信号，从而解除阻塞为止。</p>
<ol>
<li>阻塞当前正在处理的信号。即，如果当前接收到s信号，正在执行S信号处理函数处理，此时又来了一个s信号，则s会变成待处理没有被接收。</li>
<li>调用sigprocmask及其相关函数，明确地阻塞或解除阻塞信号。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *restrict set, <span class="type">sigset_t</span> *restrict oset)</span></span>; <span class="comment">// </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>; <span class="comment">// 初始化set为空集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>; <span class="comment">// 将每个信号都加到set中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span></span>; <span class="comment">// 将signum信号添加到set中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span></span>; <span class="comment">// 从set中删除signum信号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span></span>; <span class="comment">// 检查signum信号是否在set信号集中。</span></span><br></pre></td></tr></table></figure>

<p>sigprocmask改变当前阻塞的信号集合。取决于<code>how</code>参数的设定。<br>SIG_BLOCK: 将set指向信号集内的指定信号添加到信号掩码中。<br>SIG_UNBLOCK: 将set指向信号集中的信号从信号掩码中移除。即使要解除阻塞的信号当前并未处于阻塞状态，也不会返回错误<br>SIG_SETMASK: 将 set 指向的信号集赋给信号掩码。</p>
<p>如下代码展示如何临时阻塞接收SIGINT</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sigset_t block_set, prev_set;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sigempty</span>(&amp;block_set);</span><br><span class="line"><span class="built_in">sigaddset</span>(&amp;block_set, SIGINT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 阻塞SIGINT，保存先前的信号掩码 */</span></span><br><span class="line"><span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;blcok_set, &amp;prev_set);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此执行代码，不会被SIGINT打断。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复先前的信号掩码 */</span></span><br><span class="line"><span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev_mask, NULL);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/258885880">https://zhuanlan.zhihu.com/p/258885880</a></p>
<h1 id="编写信号处理程序"><a href="#编写信号处理程序" class="headerlink" title="编写信号处理程序"></a>编写信号处理程序</h1><p>信号处理是Linux系统编程最棘手的一个问题。处理程序又几个属性使得它们很难推理分析：</p>
<ul>
<li>处理程序与主程序并发运行，共享同样的全局变量。因此可能与主程序和其他信号处理程序互相干扰</li>
<li>如何以及何时接收信号的规则常常有违人的直觉</li>
<li>不同的系统有不同的信号处理语义</li>
</ul>
<p>图8-31.<br>信号处理程序很麻烦的是因为他们和主程序以及其他信号处理程序并发的执行。如果这些程序都需要访问修改同样的全局变量。将导致不可预知的结果。</p>
<p>《深入理解计算机系统》提出了安全的编写信号处理程序的几个建议：</p>
<ol>
<li>处理程序要尽可能简单。例如，信号处理程序只设置全局标志位并立即返回。</li>
<li>在主程序只调用异步信号安全函数。异步信号安全函数是指那些可重入函数或者不能被信号中断的函数。</li>
<li>保存和恢复errno。许多Linux异步信号安全函数都会在返回时设置errno。在信号处理程序中调用这样的函数会干扰主程序中其他依赖errno的部分。</li>
<li>阻塞所有信号，保护对共享全局数据结构的访问。</li>
<li>用volatile生命全局变量。volatile强制编译器每次在代码中引用被其修饰的变量时都要从内存重新读取。</li>
<li>用sig_atomic_t生命标志。C语言提供整型数据类型sig_atomic_t，对它的读写保证是原子性的。</li>
</ol>
<p>eg： libevent中的信号处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __cdecl</span></span><br><span class="line"><span class="function"><span class="title">evsig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 保存错误码</span></span><br><span class="line">    <span class="type">int</span> save_errno = errno;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="type">int</span> socket_errno = <span class="built_in">EVUTIL_SOCKET_ERROR</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">ev_uint8_t</span> msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (evsig_base == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">event_warnx</span>(</span><br><span class="line">            <span class="string">"%s: received signal %d, but have no base configured"</span>,</span><br><span class="line">            __func__, sig);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EVENT__HAVE_SIGACTION</span></span><br><span class="line">    <span class="built_in">signal</span>(sig, evsig_handler);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wake up our notification mechanism */</span></span><br><span class="line">    msg = sig;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">send</span>(evsig_base_fd, (<span class="type">char</span>*)&amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    {</span><br><span class="line">    <span class="comment">// 向读端fd，写入一个字节信号值。write是信号安全函数。</span></span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">write</span>(evsig_base_fd, (<span class="type">char</span>*)&amp;msg, <span class="number">1</span>);</span><br><span class="line">        (<span class="type">void</span>)r; <span class="comment">/* Suppress 'unused return value' and 'unused var' */</span></span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    errno = save_errno;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">EVUTIL_SET_SOCKET_ERROR</span>(socket_errno);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>libevent的信号处理程序遵守了1，2，3规则。信号处理程序很简单，仅仅往一个文件描述符中写入一个字节数据。只调用write信号安全函数，避免调用一些非信号安全的函数。因为write系统调用可能会改变errno，因此保存回复了errno的值。</p>
<p>信号处理时只是记录了下产生了什么信号,并没有进行实际处理,处理过程还是交给主程序本身,避免调用一些非信号安全的函数。因此我们再编写信号处理函数的时候也只要记录下信号状态，对errno这种全局变量，进行保存，处理结束后恢复变量值，尽量避免使用锁。</p>
<p>注：</p>
<ol>
<li>创建一个管道(Libevent实际上使用的是socketpair)</li>
<li>为这个socketpair的一个读端创建一个event，并将之加入到多路IO复用函数的监听之中</li>
<li>设置信号捕抓函数</li>
<li>有信号发生，就往socketpair写入一个字节<br>这里只展示libevent如何处理信号，需更深入了解libevent对信号的处理，可参考如下博客，或libevent源码。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/luotuo44/article/details/38538991">https://blog.csdn.net/luotuo44/article/details/38538991</a></li>
</ol>
<p>程序。<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ourroad/p/4834383.html">https://www.cnblogs.com/ourroad/p/4834383.html</a><br>如图8-31.<br>主程序收到s信号。执行s信号处理程序S。在S执行过程中，收到t信号，t信号终端S程序，转而执行T信号处理程序。T返回时，S从它被中断的地方继续执行。最后S返回，主程序从被中断的地方继续执行。</p>
<p>操作系统内核使用一种成为上下文切换的较高层形式的异常控制流来实现多任务。内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占进程所需的状态。<br>上下文切换：1. 保存当前进程的上下文。2. 回复某个先前被抢占的进程被保存的上下文。3. 将控制权传递给这个回复的进程。</p>
<h1 id="多线程程序中使用信号"><a href="#多线程程序中使用信号" class="headerlink" title="多线程程序中使用信号"></a>多线程程序中使用信号</h1><p>本来编写信号处理程序就很难了，多线程程序本身也很难，多线程+信号简直是强人锁男，男上加男嘛。应该尽量避免将两者结合起来使用，不然写出了Bug，就只能一言难尽了。</p>
<h1 id="POSIX信号和多线程应用"><a href="#POSIX信号和多线程应用" class="headerlink" title="POSIX信号和多线程应用"></a>POSIX信号和多线程应用</h1><p>POSIX 1003.1标准对多线程应用的信号处理有一些严格的要求：</p>
<ul>
<li><strong>信号处理程序必须在多线程应用的所有线程之间共享</strong>；不过，每个线程必须有自己的挂起信号掩码和阻塞掩码</li>
<li>POSIX库函数<strong>kill()<strong>和</strong>sigqueue()<strong>必须向</strong>所有</strong>的多线程应用而不是某个特殊的线程发送信号。所有由内核产生的信号同样如此(如：SIGCHLD、SIGINT或SIGQUIT)</li>
<li>每个发送给多线程应用的信号仅传递给一个线程，这个线程是由内核在从<strong>不会阻塞该信号的线程</strong>中随意选择出来的。</li>
<li>如果向多线程应用发送了一个致命的信号，那么内核将<strong>杀死该应用的所有线程</strong>，而不仅仅是杀死接收信号的那个线程。</li>
</ul>
<p>如果一个挂起的信号发送给了某个特定的进程，那么这个信号就是私有的；如果被发送给了整个线程组，它就是共享的。<br>每种信号类型对应一个元素，Linux中可以声明的信号的最大数是64。没有值为0的信号，因此，信号的编号对应于sigset_t类型变量中的相应位下标加1</p>
<h1 id="给指定线程发送信号"><a href="#给指定线程发送信号" class="headerlink" title="给指定线程发送信号"></a>给指定线程发送信号</h1><ol>
<li>pthread_kill类似kill，但pthread_kill给<strong>指定的线程</strong>发送信号。kill会给所有的线程发送信号。</li>
<li>pthread_sigqueue类似sigqueue，但pthread_sigqueue给<strong>指定的线程</strong>发送实时信号。sigqueue会给所有的线程发送实时信号。</li>
</ol>
<p>将信号发给指定线程和发给线程组有很大不同。信号发送给指定线程，由<strong>指定线程</strong>调用信号处理程序对其进行处理；信号发给线程组，且该线程组已然为此信号创建了信号处理程序时，内核会<strong>任选一条线程来接收</strong>这一信号，并在<strong>该线程</strong>中调用信号处理程序对其进行处理。</p>
<h1 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h1><p>发送给进程一个信号，这个信号可能来自内核，也可能来自另一个进程。内核通过表所示的某个函数进行调用而产生信号。最后都会调用specific_send_sig_info函数。</p>
<p>当一个信号被发往整个线程组时，这个信号可能来自内核，也可能来自另一个进程。最终都调用group_send_sig_info函数。<br>__group_complete_signal 扫描线程组中的进程，查找能接收新信号的进程。满足以下条件可能被选中。<br>每当从内核态向用户态转换时，内核态堆栈都被清空。</p>
<p>系统调用重新执行。系统调用执行到一半时接收到一个信号，去执行信号处理函数。</p>
<h1 id="发送信号-1"><a href="#发送信号-1" class="headerlink" title="发送信号"></a>发送信号</h1><h1 id="案例分析–localtime-r导致的死锁问题。"><a href="#案例分析–localtime-r导致的死锁问题。" class="headerlink" title="案例分析–localtime_r导致的死锁问题。"></a>案例分析–localtime_r导致的死锁问题。</h1><p>这里分析由我的一个提交引入的死锁问题。</p>
<p>localtime_r是线程安全函数，但不是信号安全函数。进程A执行过程中使用localtime_r，信号处理程序也调用了localtime_r函数localtime_r会调用到tz_convert上锁。如果进程A调用localtime_r已经上锁了，此时进程A收到信号去执行信号处理函数，信号处理函数也调用localtime_r，就会导致死锁发生。<br>如下程序模拟了在信号处理程序中调用localtime_r导致的死锁问题。主线程创建子线程和发送信号线程，注册信号处理程序，在信号处理程序中调用localtime_r函数。子线程处理函数中频繁调用localtime_r。发送信号线程每隔1s给指定线程id的线程发送信号。<br>从实验的结果来看：</p>
<ol>
<li>给子线程发送信号会导致死锁。</li>
<li>给主线程和发送信号线程发送信号不会导致死锁。<br>原因在于，子线程处理程序频繁调用localtime_r函数。信号处理函数也调用localtime_r函数。当子线程处理函数调用localtime_r上锁后还没来得及释放锁，此时收到信号。执行信号处理程序又调用localtime_r请求上锁。从而导致死锁。<br>而主线程和发送信号线程由于没有调用localtime_r，因而给主线程和信号发送线程发送信号不会导致死锁。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">tm</span> *</span><br><span class="line"><span class="built_in">localtime_r</span> (<span class="type">const</span> <span class="type">time_t</span> *t, <span class="keyword">struct</span> tm *tp)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tm</span> *l = <span class="built_in">localtime</span> (t);</span><br><span class="line">  <span class="keyword">if</span> (! l)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  *tp = *l;</span><br><span class="line">  <span class="keyword">return</span> tp;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> *</span><br><span class="line">__localtime64_r (<span class="type">const</span> <span class="type">__time64_t</span> *t, <span class="keyword">struct</span> tm *tp)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">return</span> __tz_convert (*t, <span class="number">1</span>, tp);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>pthread_kill发出的信号，只有该线程收到信号并处理。<br>如果<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/coding-my-life/p/4782529.html">https://www.cnblogs.com/coding-my-life/p/4782529.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34067049/article/details/87957176">https://blog.csdn.net/weixin_34067049/article/details/87957176</a></p>
<h1 id="非信号安全函数带来的风险。死锁风险分析"><a href="#非信号安全函数带来的风险。死锁风险分析" class="headerlink" title="非信号安全函数带来的风险。死锁风险分析"></a>非信号安全函数带来的风险。死锁风险分析</h1><p>死锁概念以及如何避免死锁，已有博客说明，这里不再详细说明。<br>localtime_r带来的死锁风险。<br>测试代码：注：该程序运行在Linux archlinux 5.10.43-1-lts 中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> g_main_thread_id;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> g_sub_thread_id;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> g_send_sig_thread_id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_handler</span><span class="params">(<span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">time_t</span> time_s = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> now_time;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 信号处理程序调用localtime_r非信号安全函数。</span></span><br><span class="line">    <span class="built_in">localtime_r</span>(&amp;time_s, &amp;now_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get signum %d, the thread_id is %lu\n"</span>, signum, <span class="built_in">pthread_self</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">send_sig_func</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 发送给main线程处理，不会导致死锁。</span></span><br><span class="line">        <span class="comment">// pthread_kill(g_main_thread_id, SIGUSR1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送给send_sig线程，不会导致死锁。</span></span><br><span class="line">        <span class="comment">// pthread_kill(g_send_sig_thread_id, SIGUSR1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送给子线程处理，会导致死锁。子线程处理函数和信号处理都调用了localtime_r</span></span><br><span class="line">        <span class="built_in">pthread_kill</span>(g_sub_thread_id, SIGUSR1);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">call_localtime_r</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">time_t</span> time_s = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> now_time;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">localtime_r</span>(&amp;time_s, &amp;now_time);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">    <span class="type">sigset_t</span> block_set;</span><br><span class="line"></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = sig_handler;</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGUSR1, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取主线程的线程id */</span></span><br><span class="line">    g_main_thread_id = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"g_main_thread_id = %lu\n"</span>, g_main_thread_id);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;g_sub_thread_id, <span class="literal">NULL</span>, call_localtime_r, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"g_sub_thread_id = %lu\n"</span>, g_sub_thread_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送信号线程 */</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;g_send_sig_thread_id, <span class="literal">NULL</span>, send_sig_func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"g_send_sig_thread_id = %lu\n"</span>, g_send_sig_thread_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注意，省略了错误检查 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(g_sub_thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(g_send_sig_thread_id, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>打印</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(gdb) thread apply all bt</span><br><span class="line"></span><br><span class="line">Thread <span class="number">3</span> (Thread <span class="number">0</span>x7fcb80b84640 (LWP <span class="number">3602</span>) <span class="string">"a.out"</span>): <span class="comment">// g_send_sig_thread_id</span></span><br><span class="line">#<span class="number">0</span>  <span class="number">0</span>x00007fcb8144fa95 in clock_nanosleep@GLIBC_2.<span class="number">2.5</span> () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0</span>x00007fcb81454c77 in nanosleep () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0</span>x00007fcb81454bae in sleep () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">3</span>  <span class="number">0</span>x000055c310a54276 in send_sig_func () at test_localtime_r.c:<span class="number">42</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0</span>x00007fcb8155e259 in start_thread () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libpthread.so.<span class="number">0</span></span><br><span class="line">#<span class="number">5</span>  <span class="number">0</span>x00007fcb814875e3 in clone () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line"></span><br><span class="line">Thread <span class="number">2</span> (Thread <span class="number">0</span>x7fcb81385640 (LWP <span class="number">3601</span>) <span class="string">"a.out"</span>): <span class="comment">// g_sub_thread_id</span></span><br><span class="line">#<span class="number">0</span>  <span class="number">0</span>x00007fcb8140e0ab in __lll_lock_wait_private () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0</span>x00007fcb81445fb1 in __tz_convert () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0</span>x000055c310a54214 in sig_handler (signum=<span class="number">10</span>) at test_localtime_r.c:<span class="number">25</span></span><br><span class="line">#<span class="number">3</span>  &lt;signal handler called&gt;</span><br><span class="line">#<span class="number">4</span>  <span class="number">0</span>x00007fcb81445940 in __tzset_parse_tz () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">5</span>  <span class="number">0</span>x00007fcb81447403 in __tzfile_compute () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">6</span>  <span class="number">0</span>x00007fcb81445e66 in __tz_convert () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">7</span>  <span class="number">0</span>x000055c310a542b4 in call_localtime_r () at test_localtime_r.c:<span class="number">52</span></span><br><span class="line">#<span class="number">8</span>  <span class="number">0</span>x00007fcb8155e259 in start_thread () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libpthread.so.<span class="number">0</span></span><br><span class="line">#<span class="number">9</span>  <span class="number">0</span>x00007fcb814875e3 in clone () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> (Thread <span class="number">0</span>x7fcb81386740 (LWP <span class="number">3600</span>) <span class="string">"a.out"</span>): <span class="comment">// g_main_thread_id</span></span><br><span class="line">#<span class="number">0</span>  <span class="number">0</span>x00007fcb8156a8ca in __futex_abstimed_wait_common64 () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libpthread.so.<span class="number">0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0</span>x00007fcb8155f743 in __pthread_clockjoin_ex () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libpthread.so.<span class="number">0</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0</span>x000055c310a543d1 in main () at test_localtime_r.c:<span class="number">79</span></span><br></pre></td></tr></table></figure>

<p>glibc中tz_convet代码<br>struct tm *<br>__tz_convert (__time64_t timer, int use_localtime, struct tm *tp)<br>{<br>  long int leap_correction;<br>  int leap_extra_secs;</p>
<p>  __libc_lock_lock (tzset_lock);</p>
<p>  /* Update internal database according to current TZ setting.<br>     POSIX.1 8.3.7.2 says that localtime_r is not required to set tzname.<br>     This is a good idea since this allows at least a bit more parallelism.  */<br>  tzset_internal (tp == &amp;_tmbuf &amp;&amp; use_localtime);</p>
<p>  if (__use_tzfile)<br>    __tzfile_compute (timer, use_localtime, &amp;leap_correction,<br>              &amp;leap_extra_secs, tp);<br>  else<br>    {<br>      if (! __offtime (timer, 0, tp))<br>    tp = NULL;<br>      else<br>    __tz_compute (timer, tp, use_localtime);<br>      leap_correction = 0L;<br>      leap_extra_secs = 0;<br>    }</p>
<p>  __libc_lock_unlock (tzset_lock);</p>
<p>  if (tp)<br>    {<br>      if (! use_localtime)<br>    {<br>      tp-&gt;tm_isdst = 0;<br>      tp-&gt;tm_zone = “GMT”;<br>      tp-&gt;tm_gmtoff = 0L;<br>    }</p>
<pre><code>  if (__offtime (timer, tp-&gt;tm_gmtoff - leap_correction, tp))
    tp-&gt;tm_sec += leap_extra_secs;
  else
tp = NULL;
}
</code></pre>
<p>  return tp;<br>}</p>
<p>从以上分析就能知道为什么我这个提交会导致死锁了。这个提交，将pthread_kill改成了sigqueue。<br>原本是由xxxx线程执行信号处理程序。变成内核会<strong>任选一条线程来接收</strong>这一信号。main线程没有阻塞xxx信号。很有可能学到main程序来执行信号处理程序。main程序本身也有调用localtime_r，信号处理程序也调用localtime_r。这样就导致了死锁。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>不知道哪位名人说过：未经反省的人生是不值得过的。由于写了一个Bug，因而写了这边博客反省一下。博文若有不正确的地方还请各位同事指出，让我在反省反省~</p>
<h1 id="PyTorch-Code"><a href="#PyTorch-Code" class="headerlink" title="PyTorch Code"></a>PyTorch Code</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="">论文地址</a><br><a href="">参考代码</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/26/computer%20science/Linux-kernel-module/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Z.J. Jiang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/26/computer%20science/Linux-kernel-module/" class="post-title-link" itemprop="url">Linux kernel module</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-26 23:26:54" itemprop="dateCreated datePublished" datetime="2021-05-26T23:26:54+08:00">2021-05-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2021/05/26/computer%20science/Linux-kernel-module/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2021/05/26/computer%20science/Linux-kernel-module/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>762</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是内核模块"><a href="#什么是内核模块" class="headerlink" title="什么是内核模块"></a>什么是内核模块</h1><p>内核模块是可以根据需要加载和卸载到内核中的代码片段。它们扩展了内核的功能，而无需重新启动系统。例如，一种类型的内核模块是设备驱动程序，它允许内核访问连接到系统的硬件(例如nvmp中GPIO驱动电机就编译成了内核模块，在比如wifi驱动)。如果没有内核模块，我们将不得不构建庞大的内核，并将新功能直接添加到内核image中。除了拥有更大的内核外，这还有一个缺点，即每次需要新功能时都需要重新构建和重新启动内核。</p>
<!---more--->

<h1 id="模块加载进内核的方法"><a href="#模块加载进内核的方法" class="headerlink" title="模块加载进内核的方法"></a>模块加载进内核的方法</h1><ul>
<li>通过使用<code>insmod xxx.ko</code>可将模块加载进内核。</li>
<li>通过<code>modprobe xxx</code>加载模块。<br>两者不同的是，insmod要求传递完整的路径名并按正确的顺序插入模块，而modprobe只接受名称，没有任何扩展名，并通过解析<code>/lib/modules/version/modules.dep</code>找出模块的依赖关系</li>
</ul>
<h1 id="从hello-world出发构建最简单的模块"><a href="#从hello-world出发构建最简单的模块" class="headerlink" title="从hello world出发构建最简单的模块"></a>从hello world出发构建最简单的模块</h1><p>以下代码是一个最简单的内核模块。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">hello_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">printk</span>(KERN_INFO <span class="string">"Hello, world!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">printk</span>(KERN_INFO <span class="string">"Goodbye, world!\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(hello_init);</span><br><span class="line"><span class="built_in">module_exit</span>(hello_exit);</span><br></pre></td></tr></table></figure>

<h1 id="Training-Detail"><a href="#Training-Detail" class="headerlink" title="Training Detail"></a>Training Detail</h1><h1 id="PyTorch-Code"><a href="#PyTorch-Code" class="headerlink" title="PyTorch Code"></a>PyTorch Code</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="">论文地址</a><br><a href="">参考代码</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/19/computer%20science/Static-Link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Z.J. Jiang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/19/computer%20science/Static-Link/" class="post-title-link" itemprop="url">Static Link</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-19 23:46:56" itemprop="dateCreated datePublished" datetime="2021-04-19T23:46:56+08:00">2021-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2021/04/19/computer%20science/Static-Link/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2021/04/19/computer%20science/Static-Link/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在日常的开发中很多时候都会遇到链接问题。比如，缺少模块、缺少库或者库版本不兼容导致的链接问题；错误定义多个全局变量导致程序运行产生不可预知的错误。为了减少这些错误的发生，我们应当理解链接过程。本文主要讨论静态链接。</p>
<!---more--->

<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>接下来主要通过下面简单的例子来介绍静态链接。</p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main.c:</span><br><span class="line"><span class="type">int</span> <span class="built_in">sum</span>(<span class="type">int</span> *a, <span class="type">int</span> n);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="built_in">sum</span>(<span class="type">array</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sum</span>.c</span><br><span class="line"><span class="built_in">int</span> <span class="keyword">sum</span>(<span class="built_in">int</span> *a, <span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i, s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用gcc命令将上述两文件编译成可执行程序。</p>
<p>我们使用最简单的例子来学习静态链接。main函数初始化一个int形的array数组。然后调用sum函数计算array个各元素的和。</p>
<h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><p>为了构造可执行文件，链接器必须完成两个主要任务</p>
<ol>
<li>符号解析。一个函数，全局变量或者静态变量可以是一个符号，局部变量在栈空间分配，不是一个符号。符号解析的目的是将每个符号引用正好一个符号定义关联起来。</li>
<li>重定位。编译器和链接器生成以地址0开始的代码段和数据段。这些地址并不是程序执行时的真正地址，因此需要通过链接器修正所有符号的引用，使它们的地址为程序执行时的真正地址。</li>
</ol>
<h1 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h1><p>目标文件有三种形式</p>
<ul>
<li>可重定位文件。包含代码和数据，可以被用来链接成可执行文件或共享目标文件。</li>
<li>可执行文件。可直接复制到内存并执行。</li>
<li>共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</li>
</ul>
<h1 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h1><p>目标文件将代码，数据，符号表，调试信息等不同属性的信息，以段的形式存储。一个目标文件中有多个段。</p>
<ul>
<li>ELF头。可以使用readelf命令查看ELF文件头信息。ELF文件头定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量等。</li>
<li>.text。已编译程序的机器代码</li>
<li>.rodata。只读数据，例如printf语句中的格式化输出字符串。</li>
<li>.data。已初始化的全局和静态变量。</li>
<li>.bss。未初始化或初始化为0的全局和静态变量。未初始化变量不占用任何磁盘空间。运行是，在内存分配这些变量，初始值为0</li>
<li>.symtab。符号表，存放程序中定义和引用的函数和全局变量的信息。</li>
<li>.rel.text。代码段重定位表。根据其中存储的符号offset值可以计算出符号正确地址，</li>
<li>.rel.data。数据段重定位表。</li>
<li>.strtab。字符串表。保存字符串，符号的名字，段名等。</li>
</ul>
<h1 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h1><p>每个目标文件都有一个相应的符号表，这个表记录了目标文件定义和引用的所有符号。一般有三种不同的符号：</p>
<ul>
<li>定义在本目标文件的全局符号，可被其他目标文件使用。对应在本目标文件中定义的非static的函数和全局变量。</li>
<li>定义在其他目标文件，在本目标文件中引用的全局变量。对应在其他目标文件定义的非static的函数和全局变量。</li>
<li>在本目标文件定义和引用的局部符号。对应static修饰的函数或变量。</li>
</ul>
<h2 id="符号表的结构"><a href="#符号表的结构" class="headerlink" title="符号表的结构"></a>符号表的结构</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>	st_name; <span class="comment">/* string table offset */</span></span><br><span class="line">    <span class="type">char</span> type:<span class="number">4</span>, <span class="comment">/* Function or data (4bits) */</span></span><br><span class="line">         bingding:<span class="number">4</span>;  <span class="comment">/* Local or global (4bits) */</span></span><br><span class="line">    <span class="type">char</span> reserved;  <span class="comment">/* unused */</span></span><br><span class="line">    <span class="type">short</span>	section; <span class="comment">/* section header index */</span></span><br><span class="line">    <span class="type">long</span>	value; <span class="comment">/* section offset or absolute address */</span></span><br><span class="line">    <span class="type">long</span>	size;  <span class="comment">/* object size in bytes */</span></span><br><span class="line">&#125; Elf64_Sym; </span><br></pre></td></tr></table></figure>
<ul>
<li>name。字符串表的偏移量。</li>
<li>type。符号类型</li>
<li>binding。符号是本地的还是全局的。</li>
<li>section。到段表(section header)的索引</li>
<li>value。表示偏移量或者绝对地址。</li>
<li>size。符号的大小。<br>可以使用readelf工具分析上文提到的例子的目标文件。<br><code>readelf -s main.o</code>可以得到以下输出：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Num:    <span class="keyword">Value</span>          Size <span class="keyword">Type</span>    Bind   Vis      Ndx <span class="type">Name</span></span><br><span class="line">  <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  <span class="keyword">LOCAL</span>  <span class="keyword">DEFAULT</span>  UND </span><br><span class="line">  <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    <span class="keyword">LOCAL</span>  <span class="keyword">DEFAULT</span>  ABS main.c</span><br><span class="line">  <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION <span class="keyword">LOCAL</span>  <span class="keyword">DEFAULT</span>    <span class="number">1</span> </span><br><span class="line">  <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">8</span> <span class="keyword">OBJECT</span>  <span class="keyword">GLOBAL</span> <span class="keyword">DEFAULT</span>    <span class="number">3</span> <span class="keyword">array</span></span><br><span class="line">  <span class="number">4</span>: <span class="number">0000000000000000</span>    <span class="number">33</span> FUNC    <span class="keyword">GLOBAL</span> <span class="keyword">DEFAULT</span>    <span class="number">1</span> main</span><br><span class="line">  <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  <span class="keyword">GLOBAL</span> <span class="keyword">DEFAULT</span>  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">  <span class="number">6</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  <span class="keyword">GLOBAL</span> <span class="keyword">DEFAULT</span>  UND sum</span><br></pre></td></tr></table></figure>
可以得知符号main是一个位于.text段偏移量为0的33字节函数。array是一个位于.data段的偏移量为0的8字节符号。</li>
</ul>
<h1 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h1><h2 id="解析多重定义的全局符号"><a href="#解析多重定义的全局符号" class="headerlink" title="解析多重定义的全局符号"></a>解析多重定义的全局符号</h2><p>函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。针对强弱符号的概念，linux链接器使用如下规则处理多重定义的符号名</p>
<ul>
<li>规则1: 不允许强符号被多次定义</li>
<li>规则2: 如果一个强符号和多个弱符号同名，那么选择强符号。</li>
<li>规则3: 如果有多个弱符号同名，那么从这些弱符号中任意选择一个。(程序员自我修养中说到是选择占用空间最大的符号。)</li>
</ul>
<ol>
<li><p>example 1</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>符号a是一个强符号，被定义了两次。编译这段程序会提示：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test.c:<span class="number">2</span>:<span class="number">5</span>: error: redefinition of ‘a’</span><br><span class="line">    <span class="number">2</span> <span class="string">| int a = 1;</span></span><br><span class="line">      <span class="string">|     ^</span></span><br><span class="line">test.c:<span class="number">1</span>:<span class="number">5</span>: note: previous definition of ‘a’ was here</span><br><span class="line">    <span class="number">1</span> <span class="string">| int a = 0;</span></span><br><span class="line">      <span class="string">|     ^</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>example 2:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* func.c */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="number">20000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>gcc -o main test.c func.c &amp;&amp; ./main</code>应该打印<code>x = 20000</code><br>然而，实际上在我的电脑测试并不能成功通过编译。gcc版本是10.2.0。经查证，gcc 10.0以上的版本编译默认从-fcommon转到-fno-common.-fno-common选项告诉链接器，遇到重定义符号，就触发一个错误。</p>
<p>使用<code>gcc -o main test.c func.c -fcommon &amp;&amp; ./main</code>打印<code>x = 20000</code>。</p>
<ol start="3">
<li>example3<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">20000</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = 0x%x y = 0x%x \n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* func.c */</span></span><br><span class="line"><span class="type">double</span> x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="number">-0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>使用<code>gcc -o main test.c func.c -fcommon &amp;&amp; ./main</code>,编译过程只会产生一条警告信息<code>/usr/bin/ld: warning: alignment 4 of symbol x in /tmp/cc9XEYKu.o is smaller than 8 in /tmp/ccTc5xbh.o</code>输出<code>x=0x0 y = 80000000</code>(double数-0.0的二进制表示是0x80000000)。<br>这是一个微小的错误，但有时难以发现，可能在程序运行很久之后才表现出来。我们应该如何避免呢？</p>
<ul>
<li>使用全局变量时就将其初始化，使之成为一个强符号。</li>
<li>gcc编译的时候使用-fno-common选项</li>
<li>gcc编译使用-Werror选项，将所有警告都变成错误</li>
</ul>
<h1 id="静态库的链接顺序"><a href="#静态库的链接顺序" class="headerlink" title="静态库的链接顺序"></a>静态库的链接顺序</h1><p>静态库链接时候需要满足一定的顺序，有时改变某两个静态库的顺序就不能链接成功了。在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和静态库。<strong>在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能解析，链接会失败</strong></p>
<p>例如，可以重新编译上述的example2。使用下列命令将func.c编译成func.a静态库。</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="keyword">c</span> -fcommon func.<span class="keyword">c</span></span><br><span class="line">gcc -<span class="keyword">c</span> -fcommon test.<span class="keyword">c</span></span><br><span class="line">ar rcs libfunc.a func.o</span><br></pre></td></tr></table></figure>
<p>使用下列命令可以成功编译。<br>gcc -static -o main test.o .&#x2F;libfunc.a<br>而使用<br>gcc -static -o main .&#x2F;libfunc.a test.o<br>则编译不通过，提示找不到符号</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: test.o: <span class="keyword">in</span> <span class="keyword">function</span> `main<span class="comment">&#x27;:</span></span><br><span class="line">test.c:(.<span class="keyword">text</span>+<span class="number">0</span>x5): undefined reference <span class="keyword">to</span> `func<span class="comment">&#x27;</span></span><br><span class="line"><span class="symbol">collect2:</span> <span class="keyword">error</span>: ld returned <span class="number">1</span> <span class="keyword">exit</span> status</span><br></pre></td></tr></table></figure>
<p>在命令行命令编译过程中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接就会失败。因此尤其需要考虑库的位置。必须确保对符号的引用出现在该符号定义之前。</p>
<h1 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h1><p>编译器遇到对最终位置未知的目标引用，它就会产生一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中。已初始化数据的重定位条目放在.rel.data中。下面结构体展示了重定位条目的格式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> offset;    <span class="comment">/* offset of the referenct to relocate */</span></span><br><span class="line">    <span class="type">long</span> type:<span class="number">32</span>,   <span class="comment">/* relocation type */</span></span><br><span class="line">         symbol:<span class="number">32</span>; <span class="comment">/* Symbol table index */</span></span><br><span class="line">    <span class="type">long</span> addend;    <span class="comment">/* constant part of relocation expression */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>offset。需要被修改的引用的节偏移。</li>
<li>type。重定位类型，这里只讨论R_X86_64_PC32(相对地址引用)和R_X86_64_32(绝对地址引用)两种。</li>
<li>symbol。被修改引用应该指向的符号。</li>
<li>addend。相对地址引用中需要使用该值对被修改引用的值做位置偏移。<br>下面对本文最开始提到的main.o做重定位。使用<code>objdump -d main.o</code>查看反汇编代码。<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0000000000000000</span> &lt;main&gt;:</span><br><span class="line">   <span class="attribute">0</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">   <span class="attribute">1</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">   <span class="attribute">4</span>:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0</span>x10,%rsp</span><br><span class="line">   <span class="attribute">8</span>:   be <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0</span>x2,%esi</span><br><span class="line">   <span class="attribute">d</span>:   <span class="number">48</span> <span class="number">8</span>d <span class="number">3</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0</span>x0(%rip),%rdi        # <span class="number">14</span> &lt;main+<span class="number">0</span>x14&gt;</span><br><span class="line">  <span class="attribute">14</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">19</span> &lt;main+<span class="number">0</span>x19&gt;</span><br><span class="line">  <span class="attribute">19</span>:   <span class="number">89</span> <span class="number">45</span> fc                mov    %eax,-<span class="number">0</span>x4(%rbp)</span><br><span class="line">  <span class="attribute">1c</span>:   <span class="number">8</span>b <span class="number">45</span> fc                mov    -<span class="number">0</span>x4(%rbp),%eax</span><br><span class="line">  <span class="attribute">1f</span>:   c9                      leave  </span><br><span class="line">  <span class="attribute">20</span>:   c3                      ret     </span><br></pre></td></tr></table></figure>
对sum地址的引用为相对引用。相应的重定位条目r由4个字段组成:<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">r.offset</span> = <span class="number">0</span>xf</span><br><span class="line"><span class="attr">r.symbol</span> = sum</span><br><span class="line"><span class="attr">r.type</span> = R_X<span class="number">86_64_</span>PC32</span><br><span class="line"><span class="attr">r.addend</span> = -<span class="number">4</span></span><br></pre></td></tr></table></figure>
现在假定编译器链接完之后，sum符号的地址是0x000000000000113a，main符号的地址是0x0000000000001119。那么如何根据这两个地址计算出sum引用的地址呢？<br>在调用call是，PC的值为call指令之后的指令地址，也就是0x0000000000001119 + 13 &#x3D; 0x0000000000001132<br>也就是说0x0000000000001132 + x &#x3D; 0x000000000000113a, 计算得到x为8。如下所示：<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000001119</span> &lt;main&gt;:</span><br><span class="line">    <span class="number">1119</span>:       <span class="number">55</span>                      push   <span class="variable">%rbp</span></span><br><span class="line">    <span class="number">111</span>a:       <span class="number">48</span> <span class="number">89</span> e<span class="number">5</span>                mov    <span class="variable">%rsp</span><span class="punctuation">,</span><span class="variable">%rbp</span></span><br><span class="line">    <span class="number">111</span>d:       <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             <span class="keyword">sub</span>    $<span class="number">0x10</span><span class="punctuation">,</span><span class="variable">%rsp</span></span><br><span class="line">    <span class="number">1121</span>:       be <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x2</span><span class="punctuation">,</span><span class="variable">%esi</span></span><br><span class="line">    <span class="number">1126</span>:       <span class="number">48</span> <span class="number">8</span>d <span class="number">3</span>d fb <span class="number">2</span>e <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0x2efb</span>(<span class="variable">%rip</span>)<span class="punctuation">,</span><span class="variable">%rdi</span>        # <span class="number">4028</span> &lt;array&gt;</span><br><span class="line">    <span class="number">112</span>d:       e<span class="number">8</span> <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">call</span>   <span class="number">113</span>a &lt;sum&gt;</span><br><span class="line">    <span class="number">1132</span>:       <span class="number">89</span> <span class="number">45</span> fc                mov    <span class="variable">%eax</span><span class="punctuation">,</span><span class="number">-0</span><span class="keyword">x</span><span class="number">4</span>(<span class="variable">%rbp</span>)</span><br><span class="line">    <span class="number">1135</span>:       <span class="number">8</span>b <span class="number">45</span> fc                mov    <span class="number">-0</span><span class="keyword">x</span><span class="number">4</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span><span class="variable">%eax</span></span><br><span class="line">    <span class="number">1138</span>:       <span class="keyword">c</span><span class="number">9</span>                      leave  </span><br><span class="line">    <span class="number">1139</span>:       <span class="keyword">c</span><span class="number">3</span>                      <span class="keyword">ret</span>    </span><br><span class="line"></span><br><span class="line"><span class="number">000000000000113</span>a &lt;sum&gt;:</span><br><span class="line">    <span class="number">113</span>a:       <span class="number">55</span>                      push   <span class="variable">%rbp</span></span><br><span class="line">    <span class="number">113</span>b:       <span class="number">48</span> <span class="number">89</span> e<span class="number">5</span>                mov    <span class="variable">%rsp</span><span class="punctuation">,</span><span class="variable">%rbp</span></span><br><span class="line">    <span class="number">113</span>e:       <span class="number">48</span> <span class="number">89</span> <span class="number">7</span>d e<span class="number">8</span>             mov    <span class="variable">%rdi</span><span class="punctuation">,</span><span class="number">-0</span><span class="keyword">x</span><span class="number">18</span>(<span class="variable">%rbp</span>)</span><br><span class="line">    <span class="number">1142</span>:       <span class="number">89</span> <span class="number">75</span> e<span class="number">4</span>                mov    <span class="variable">%esi</span><span class="punctuation">,</span><span class="number">-0</span><span class="keyword">x</span><span class="number">1</span><span class="keyword">c</span>(<span class="variable">%rbp</span>)</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文简单介绍了静态链接。大量参考了《程序员的自我修养》和《深入理解计算机系统》这两本书。参考这两本书可以对静态链接有更深入的理解。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/03/computer%20science/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Z.J. Jiang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/03/computer%20science/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">Redis 整数集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-03 11:12:04" itemprop="dateCreated datePublished" datetime="2020-06-03T11:12:04+08:00">2020-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2020/06/03/computer%20science/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2020/06/03/computer%20science/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h1><p>整数集合(intset)是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为<br>int16_t、int32_t、int64_t的整数值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> {</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 元素的个数</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">} intset;</span><br></pre></td></tr></table></figure>
<!---more--->
<ul>
<li>encoding:保存整数集合的类型<ul>
<li>INTSETi_ENCi_INT16:保存数据类型是int16_t</li>
<li>INTSETi_ENCi_INT32:保存数据类型是int32_t</li>
<li>INTSETi_ENCi_INT64:保存数据类型是int64_t</li>
</ul>
</li>
<li>length: 保存长度信息</li>
<li>contents:保存所有的元素</li>
</ul>
<h1 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h1><p>当我们插入的数据比现有的所有数据都要长的时候需要进行数据的升级。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> intset *<span class="title function_">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="type">int64_t</span> value)</span> {</span><br><span class="line">    <span class="type">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    <span class="type">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="type">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    <span class="type">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First set new encoding and resize */</span></span><br><span class="line">    <span class="comment">// 设置encoding 并resize +1 表示需要添加的元素</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade back-to-front so we don't overwrite values.</span></span><br><span class="line"><span class="comment">     * Note that the "prepend" variable is used to make sure we have an empty</span></span><br><span class="line"><span class="comment">     * space at either the beginning or the end of the intset. */</span></span><br><span class="line">    <span class="comment">// 将原先数据移动到合适的位置</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></span><br><span class="line">    <span class="comment">// 引发升级操作 要么小于所有的数，要么大于所有的数</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        <span class="comment">// 数据是负的，太小引发升级操作</span></span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 数据是正数，太大引发升级操作</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<ul>
<li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间</li>
<li>将底层数组现有的所有元素转化成与新元素相同的类型，并放置在合适的位置上，</li>
<li>将新元素添加到合适的位置，头或尾</li>
</ul>
<h1 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h1><ul>
<li>提升灵活性</li>
<li>节约内存</li>
</ul>
<h1 id="整数集合API"><a href="#整数集合API" class="headerlink" title="整数集合API"></a>整数集合API</h1><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>*intsetNew(void)</td>
<td>创建一个新的压缩列表</td>
</tr>
<tr>
<td>*intsetAdd(intset *is, int64_t value, uint8_t *success)</td>
<td>将给定元素添加到整数集合里面</td>
</tr>
<tr>
<td>*intsetRemove(intset *is, int64_t value, int *success)</td>
<td>从整数集合移除给定元素</td>
</tr>
<tr>
<td>intsetFind(intset *is, int64_t value)</td>
<td>检查给定值是否存在在集合</td>
</tr>
<tr>
<td>intsetRandom(intset *is)</td>
<td>从整数集合中随机返回一个元素</td>
</tr>
<tr>
<td>intsetGet(intset *is, uint32_t pos, int64_t *value)</td>
<td>取出底层数组在给定索引上的元素</td>
</tr>
<tr>
<td>intsetLen(const intset *is)</td>
<td>返回整数集合包含的严肃个数</td>
</tr>
<tr>
<td>intsetBlobLen(intset *is)</td>
<td>返回整数集合占用的内存字节数</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/02/computer%20science/Redis-ziplist/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Z.J. Jiang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/02/computer%20science/Redis-ziplist/" class="post-title-link" itemprop="url">Redis ziplist</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-02 23:36:46" itemprop="dateCreated datePublished" datetime="2020-06-02T23:36:46+08:00">2020-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2020/06/02/computer%20science/Redis-ziplist/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2020/06/02/computer%20science/Redis-ziplist/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry1&gt;....&lt;entryn&gt;&lt;zlend&gt;</span><br></pre></td></tr></table></figure>
<p>上述展示了一个压缩列表的构成</p>
<ul>
<li>zlbytes:uint32_t，4字节，记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，或者计算zlend的位置时使用</li>
<li>zltail:uint32_t，4字节，记录压缩列表最后一个entry的offset。</li>
<li>zllen:uint16_t，2字节，记录压缩列表entry的个数，当值大于INT16i_MAX时，需要遍历整个压缩列表才能计算得到长度</li>
<li>entry:列表节点，</li>
<li>zlend:uint6_t，1字节，0xFF，标记压缩列表的末端<!---more---></li>
</ul>
<h1 id="压缩列表的节点"><a href="#压缩列表的节点" class="headerlink" title="压缩列表的节点"></a>压缩列表的节点</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>prevlen:记录上一个entry的长度，用于从尾向前移动<ul>
<li>如果前一个entry的长度小于254字节，那么prelen属性的长度为1个字节</li>
<li>入股前一个entry的长度大于254字节，那么prelen属性的长度为5个字节，其中第一个字节设置为0xFE，而之后的四个字节用于保存前一个节点的长度。</li>
</ul>
</li>
<li>encoding:记录entry的内容的属性和长度<ul>
<li>|00pppppp| encoding长度为一个字节，pppppp代表entry-data的长度，小于63个字节的字符串数据，字符串数据</li>
<li>|01pppppp|qqqqqqqq| encoding长度为两个字节，ppppppqqqqqqqq表示entry-data的长度，小于16383个字节的字符串数据</li>
<li>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| encoding长度为五个字节，q-t表示entry的长度，小于<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.816ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 3012.6 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>字节的字符串数据</li>
<li>|11000000| encoding长度为一个字节，encoding+entry-data为3个字节 整型数据 int16_t(2 bytes)</li>
<li>|11010000| encoding长度为一个字节，encoding+entry-data为5个字节整型数据 int32_t(4 bytes)</li>
<li>|11100000| encoding长度为一个字节，encoding+entry-data为9个字节整型数据 int64_t(8 bytes)</li>
<li>|11110000| encoding长度为一个字节，encoding+entry-data为4个字节整型数据 24bit带符号整型数据(3 bytes)</li>
<li>|11111110| encoding长度为一个字节，encoding+entry-data为2个字节整型数据 8bit带符号整型数据(1 bytes)</li>
<li>|1111xxxx| xxxx 在0001-1101(1-13)之间的数据, 计算的时候要减1(0-12).</li>
<li>|11111111| 0xFF结束标识符</li>
</ul>
</li>
<li>entry-data: 根据encoding决定存储的数据类型和长度。str 或 int</li>
</ul>
<h1 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h1><p>当插入一个entry时，因为每个entry的头部都要用一个字节或者五个字节记录上一个entry的长度<br>所以插入一个entry后，需要更新后面所有entry的prevlen，最坏情况是之后所有entry的prevlen的<br>长度都由一个字节变为五个字节。</p>
<ul>
<li>需要逐个entry更新到最后一个</li>
<li>需要收缩长度的地方，为了提高效率，我们不进行收缩，而使用5个字节表示原先用1个字节就能表示的长度<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *__ziplistCascadeUpdate(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> *p) {</span><br><span class="line">    <span class="type">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;</span><br><span class="line">    <span class="type">size_t</span> offset, noffset, extra;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *np;</span><br><span class="line">    zlentry cur, next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END) {</span><br><span class="line">        <span class="comment">// 得到当前entry</span></span><br><span class="line">        zipEntry(p, &amp;cur);</span><br><span class="line">        <span class="comment">// 当前entry的总长度</span></span><br><span class="line">        rawlen = cur.headersize + cur.len;</span><br><span class="line">        <span class="comment">// 需要用几个字节来存储当前entry的总长度，&lt;254 1 个字节， 大于254 5个字节</span></span><br><span class="line">        rawlensize = zipStorePrevEntryLength(<span class="literal">NULL</span>,rawlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Abort if there is no next entry. */</span></span><br><span class="line">        <span class="comment">// 如果p已经是最后一个entry了</span></span><br><span class="line">        <span class="keyword">if</span> (p[rawlen] == ZIP_END) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 得到下一个entry的地址</span></span><br><span class="line">        zipEntry(p+rawlen, &amp;next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Abort when "prevlen" has not changed. */</span></span><br><span class="line">        <span class="comment">// 如果下一个entry的prelen已经是正确的不需要做任何操作</span></span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlen == rawlen) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下一个entry需要用5个字节来替换1个字节存储，扩容</span></span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlensize &lt; rawlensize) {</span><br><span class="line">            <span class="comment">/* The "prevlen" field of "next" needs more bytes to hold</span></span><br><span class="line"><span class="comment">             * the raw length of "cur". */</span></span><br><span class="line">            offset = p-zl;</span><br><span class="line">            <span class="comment">// 需要增加的字节的大小</span></span><br><span class="line">            extra = rawlensize-next.prevrawlensize;</span><br><span class="line">            <span class="comment">// 重新resize</span></span><br><span class="line">            zl = ziplistResize(zl,curlen+extra);</span><br><span class="line">            p = zl+offset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Current pointer and offset for next element. */</span></span><br><span class="line">            <span class="comment">// 下一个指针地址</span></span><br><span class="line">            np = p+rawlen;</span><br><span class="line">            <span class="comment">// 下一个指针的offset</span></span><br><span class="line">            noffset = np-zl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update tail offset when next element is not the tail element. */</span></span><br><span class="line">            <span class="comment">// 改变&lt;zoffset&gt;</span></span><br><span class="line">            <span class="keyword">if</span> ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) {</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move the tail to the back. */</span></span><br><span class="line">            <span class="comment">//  需要扩张，把后面内存的东西搬到前面来</span></span><br><span class="line">            memmove(np+rawlensize,</span><br><span class="line">                np+next.prevrawlensize,</span><br><span class="line">                curlen-noffset-next.prevrawlensize<span class="number">-1</span>); </span><br><span class="line">            zipStorePrevEntryLength(np,rawlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Advance the cursor */</span></span><br><span class="line">            <span class="comment">// 指向下一个节点来继续更新操作</span></span><br><span class="line">            p += rawlen;</span><br><span class="line">            <span class="comment">// 更新当前的ziplist的长度</span></span><br><span class="line">            curlen += extra;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (next.prevrawlensize &gt; rawlensize) {</span><br><span class="line">                <span class="comment">/* This would result in shrinking, which we want to avoid.</span></span><br><span class="line"><span class="comment">                 * So, set "rawlen" in the available bytes. */</span></span><br><span class="line">                <span class="comment">// 可能会导致收缩，但是我们不做收缩 收缩效率降低</span></span><br><span class="line">                <span class="comment">// 我们此时用5个字节来表示原先1个字节就可以存储的长度</span></span><br><span class="line">                zipStorePrevEntryLengthLarge(p+rawlen,rawlen);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                zipStorePrevEntryLength(p+rawlen,rawlen);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Stop here, as the raw length of "next" has not changed. */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="压缩列表API"><a href="#压缩列表API" class="headerlink" title="压缩列表API"></a>压缩列表API</h1><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>*ziplistNew(void)</td>
<td>创建一个新的压缩列表</td>
</tr>
<tr>
<td>*ziplistMerge(unsigned char **first, unsigned char **second)</td>
<td>合并两个压缩列表</td>
</tr>
<tr>
<td>*ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where)</td>
<td>创建一个列表，添加到表头或表尾</td>
</tr>
<tr>
<td>*ziplistIndex(unsigned char *zl, int index)</td>
<td>返回压缩列表索引上的节点</td>
</tr>
<tr>
<td>*ziplistNext(unsigned char *zl, unsigned char *p)</td>
<td>得到压缩列表下一个节点</td>
</tr>
<tr>
<td>*ziplistPrev(unsigned char *zl, unsigned char *p)</td>
<td>得到压缩列表上一个节点</td>
</tr>
<tr>
<td>ziplistGet(unsigned char *p, unsigned char **sval, unsigned int *slen, long long *lval)</td>
<td>获取给定接待呢所保存的值</td>
</tr>
<tr>
<td>*ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen)</td>
<td>插入一个节点</td>
</tr>
<tr>
<td>*ziplistDelete(unsigned char *zl, unsigned char **p)</td>
<td>删除一个节点</td>
</tr>
<tr>
<td>*ziplistDeleteRange(unsigned char *zl, int index, unsigned int num)</td>
<td>删除一个范围的节点</td>
</tr>
<tr>
<td>*ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip)</td>
<td>在压缩列表中查找并返回包含了给定值的节点</td>
</tr>
<tr>
<td>ziplistLen(unsigned char *zl)</td>
<td>返回压缩列表包含节点的数量</td>
</tr>
<tr>
<td>ziplistBlobLen(unsigned char *zl)</td>
<td>返回压缩列表目前占用的字节数</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/02/computer%20science/Redis-%E5%AD%97%E5%85%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Z.J. Jiang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/02/computer%20science/Redis-%E5%AD%97%E5%85%B8/" class="post-title-link" itemprop="url">Redis 字典</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-02 14:37:55" itemprop="dateCreated datePublished" datetime="2020-06-02T14:37:55+08:00">2020-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2020/06/02/computer%20science/Redis-%E5%AD%97%E5%85%B8/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2020/06/02/computer%20science/Redis-%E5%AD%97%E5%85%B8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h1><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典的一个键值对。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> {</span></span><br><span class="line">    dictEntry **table; <span class="comment">// table是一个数组，保存指向dictEntry的指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size; <span class="comment">// 哈希表的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask; <span class="comment">// 用于计算索引 掩码 用按位与操作代替求余操作</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used; <span class="comment">// 保存哈希已经使用的大小</span></span><br><span class="line">} dictht;</span><br></pre></td></tr></table></figure>
<!---more--->
<ul>
<li>table是一个数组，保存指向dictEntry的指针，每个dictEntry都保存这一个键值对。</li>
<li>size记录啦哈希表的大小</li>
<li>sizemask是掩码，用于计算哈希表的索引，大小为size-1.本质上是用按位与操作来代替求余操作，提高计算效率。</li>
<li>used记录哈希表已使用的大小。</li>
</ul>
<h2 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h2><p>哈希表节点使用dictEntry结构表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> {</span></span><br><span class="line">    <span class="type">void</span> *key; <span class="comment">// 保存键值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    } v; <span class="comment">// 保存value值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个dictEntry的节点，形成链表，可以用来解决哈希冲突问题</span></span><br><span class="line">} dictEntry;</span><br></pre></td></tr></table></figure>
<ul>
<li>key:用来保存键值</li>
<li>v:用来保存value值</li>
<li>*next:保存指向下一节点的指针，形成链表来解决哈希碰撞问题</li>
</ul>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> {</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;  <span class="comment">// 为了实现可以存储多种类型的数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="comment">// rehash不进行是值为1</span></span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">} dict;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> {</span></span><br><span class="line">    <span class="type">uint64_t</span> (*hashFunction)(<span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">} dictType;</span><br></pre></td></tr></table></figure>
<ul>
<li>type:保存不同类型的数据，实现多态，privdata保存了type类型需要的数据</li>
<li>ht[2]:两张哈希表，通常使用ht[0]保存数据，如果进行rehashing，则ht[0]和ht[1]同时保存数据</li>
<li>rehashidx:保存rehash的进度，如果没有进行rehashing，则设置为-1.</li>
<li>iterators:保存dict有多少个迭代器正在使用</li>
</ul>
<h2 id="dict迭代器"><a href="#dict迭代器" class="headerlink" title="dict迭代器"></a>dict迭代器</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> {</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="type">long</span> index;</span><br><span class="line">    <span class="type">int</span> table, safe;</span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fingerprint;</span><br><span class="line">} dictIterator;</span><br></pre></td></tr></table></figure>
<ul>
<li>d:表示次迭代器是d的迭代器</li>
<li>index:指向数据的索引</li>
<li>table:那张哈希表</li>
<li>safe:是否安全</li>
<li>fingerprint:d的指纹</li>
</ul>
<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p>当要将一个新的键值对加入到字典里面时，需要对键值计算哈希值和索引值，根据索引值，加入到合适的哈希表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line">ind = hash &amp; dict-&gt;ht[x].sizemask;<span class="comment">//根据情况使用某张哈希表</span></span><br></pre></td></tr></table></figure>
<p>Redis使用siphash哈希functions.</p>
<h1 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h1><p>Redis的哈希表使用链表来解决冲突问题，而且是使用头插法.</p>
<h1 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h1><p>当键值越来越多时，哈希表的负载因子变大，需要重新rehash来使得访问等操作的时间复杂度降低</p>
<ul>
<li>扩展操作：将哈希表的扩展为第一个大于等于ht[x].used**2的<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.279ex" height="1.528ex" role="img" focusable="false" viewBox="0 -675.5 1007.3 675.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>。</li>
<li>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash重新计算键的哈希值和索引值，然后将键值对放置到ht[1]的指定位置上。</li>
<li>当所有ht[0]中的键值对rehash到ht[1]时，将ht[1]设置成ht[0]，然后为重新初始化ht[1].</li>
</ul>
<h1 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h1><p>Redis的rehash操作不是一次性执行玩的。而是分多次执行。一次性执行完需要消耗大量时间，庞大的计算量可能会导致<br>服务器在一段时间内停止服务。渐进rehash的过程中，使用两张哈希表来保存数据，因此，添加，删除，修改等操作需要<br>在两张哈希表中完成。</p>
<p>在渐进rehash的过程，新添加到字典的键值对一律会被保存到ht[1]中，而ht[0]不再进行任何添加操作，保证ht[0]中的元素在减少，<br>并随着rehash最后变成空表。</p>
<h1 id="字典API"><a href="#字典API" class="headerlink" title="字典API"></a>字典API</h1><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>*dictcreate(dicttype *type, void *privdataptr)</td>
<td>创建一个新字典</td>
</tr>
<tr>
<td>dictexpand(dict *d, unsigned long size)</td>
<td>扩展字典</td>
</tr>
<tr>
<td>dictAdd(dict *d, void *key, void *val)</td>
<td>添加键值对</td>
</tr>
<tr>
<td>*dictAddOrFind(dict *d, void *key)</td>
<td>添加或者寻找</td>
</tr>
<tr>
<td>dictReplace(dict *d, void *key, void *val)</td>
<td>替换</td>
</tr>
<tr>
<td>dictDelete(dict *d, const void *key)</td>
<td>删除键值对，释放资源</td>
</tr>
<tr>
<td>*dictUnlink(dict *ht, const void *key)</td>
<td>删除键值对并返回此键值对，不释放资源</td>
</tr>
<tr>
<td>dictFreeUnlinkedEntry(dict *d, dictEntry *he)</td>
<td>删除键值对的链接</td>
</tr>
<tr>
<td>dictRelease(dict *d)</td>
<td>释放Unlink的键值对</td>
</tr>
<tr>
<td>dictFind(dict *d, const void *key)</td>
<td>寻找键值对</td>
</tr>
<tr>
<td>dictResize(dict *d)</td>
<td>resize</td>
</tr>
<tr>
<td>*dictGetIterator(dict *d)</td>
<td>得到一个迭代器</td>
</tr>
<tr>
<td>*dictGetSafeIterator(dict *d)</td>
<td>得到一个安全的迭代器</td>
</tr>
<tr>
<td>*dictNext(dictIterator *iter)</td>
<td>得到字典下一个键值对</td>
</tr>
<tr>
<td>dictReleaseIterator(dictIterator *iter)</td>
<td>释放迭代器资源</td>
</tr>
<tr>
<td>*dictGetRandomKey(dict *d)</td>
<td>得到一个随机的键值对</td>
</tr>
<tr>
<td>int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count)</td>
<td>得到几个随机的键值对</td>
</tr>
<tr>
<td>dictEmpty(dict <em>d, void(callback)(void</em>))</td>
<td>清空字典</td>
</tr>
<tr>
<td>dictRehash(dict *d, int n)</td>
<td>rehash字典</td>
</tr>
<tr>
<td>dictRehashMilliseconds(dict *d, int ms)</td>
<td>在ms毫秒时间内rehash字典</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/01/computer%20science/Redis-%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Z.J. Jiang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/01/computer%20science/Redis-%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">Redis 链表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-01 16:04:59" itemprop="dateCreated datePublished" datetime="2020-06-01T16:04:59+08:00">2020-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2020/06/01/computer%20science/Redis-%E9%93%BE%E8%A1%A8/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2020/06/01/computer%20science/Redis-%E9%93%BE%E8%A1%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="list、listNode、listIter的实现"><a href="#list、listNode、listIter的实现" class="headerlink" title="list、listNode、listIter的实现"></a>list、listNode、listIter的实现</h1><ul>
<li>listIter根据direction得到一个迭代器。</li>
<li>listNode实现链表的节点，为双向链表，其value类型为void*, 因此可以存储任意类型的数据。</li>
<li>list保存链表的长度，头节点指针，尾节点指针，长度，以及复制、释放、判断相等的函数指针。<!---more--->
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表的一个Node</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">} listNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list迭代器 根据direction 生成迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> {</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="type">int</span> direction;</span><br><span class="line">} listIter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list链表 保存头节点和尾节点等信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> {</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// listNode复制的函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// listNode释放的函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 判断listNode相等的函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">} <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
Redis的链表特性可以总结如下：</li>
<li>双端：可以轻松获得某一节点的prev或next节点。</li>
<li>无环</li>
<li>带头尾节点指针：得到链表的头节点或尾节点的时间复杂度为O(1).</li>
<li>带有长度计数器：可以快速得到链表的长度</li>
<li>void* value: 通过自定义dup、free、match函数，可以存储任意类型数据，</li>
</ul>
<h1 id="list节点和listNode的API"><a href="#list节点和listNode的API" class="headerlink" title="list节点和listNode的API"></a>list节点和listNode的API</h1><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>listLength(l)</td>
<td>得到list长度</td>
<td>O(1)</td>
</tr>
<tr>
<td>listFirst(l)</td>
<td>得到头节点指针</td>
<td>O(1)</td>
</tr>
<tr>
<td>listLast(l)</td>
<td>得到尾节点的指针</td>
<td>O(1)</td>
</tr>
<tr>
<td>listPrevNode(n)</td>
<td>得到上一个节点指针</td>
<td>O(1)</td>
</tr>
<tr>
<td>listNextNode(n)</td>
<td>得到下一个节点指针</td>
<td>O(1)</td>
</tr>
<tr>
<td>listNodeValue(n)</td>
<td>得到节点的value值</td>
<td>O(1)</td>
</tr>
<tr>
<td>listSetDupMethod(l,m)</td>
<td>设置节点的复制函数</td>
<td>O(1)</td>
</tr>
<tr>
<td>listSetFreeMethod(l,m)</td>
<td>设置节点的释放函数</td>
<td>O(1)</td>
</tr>
<tr>
<td>listSetMatchMethod(l,m)</td>
<td>设置节点的match函数</td>
<td>O(1)</td>
</tr>
<tr>
<td>listGetDupMethod(l)</td>
<td>得到节点的复制函数</td>
<td>O(1)</td>
</tr>
<tr>
<td>listGetFreeMethod(l)</td>
<td>得到节点的释放函数</td>
<td>O(1)</td>
</tr>
<tr>
<td>listGetMatchMethod(l)</td>
<td>得到节点的match函数</td>
<td>O(1)</td>
</tr>
<tr>
<td>listCreate(void)</td>
<td>创建一个不包含任一节点的链表</td>
<td>O(1)</td>
</tr>
<tr>
<td>listRelease(list *list)</td>
<td>释放一个链表</td>
<td>O(N)</td>
</tr>
<tr>
<td>listEmpty(list *list)</td>
<td>释放链表所有的节点</td>
<td>O(N)</td>
</tr>
<tr>
<td>listAddNodeHead(list *list, void *value)</td>
<td>链表头插法</td>
<td>O(1)</td>
</tr>
<tr>
<td>listAddNodeTail(list *list, void *value)</td>
<td>链表尾插法</td>
<td>O(1)</td>
</tr>
<tr>
<td>listInsertNode(list *list, listNode *old_node, void *value, int after)</td>
<td>根据after的方向在old_node中插入新的节点</td>
<td>O(1)</td>
</tr>
<tr>
<td>listDelNode(list *list, listNode *node)</td>
<td>删除一个节点</td>
<td>O(1)</td>
</tr>
<tr>
<td>listGetIterator(list *list, int direction)</td>
<td>根据direction得到一个迭代器</td>
<td>O(1)</td>
</tr>
<tr>
<td>listNext(listIter *iter)</td>
<td>根据迭代器得到下一个元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>listReleaseIterator(listIter *iter)</td>
<td>释放迭代器</td>
<td>O(1)</td>
</tr>
<tr>
<td>listDup(list *orig)</td>
<td>从orig复制链表</td>
<td>O(N)</td>
</tr>
<tr>
<td>listSearchKey(list *list, void *key)</td>
<td>搜索key</td>
<td>O(N)</td>
</tr>
<tr>
<td>listIndex(list *list, long index)</td>
<td>得到index的listNode</td>
<td>O(N)</td>
</tr>
<tr>
<td>listRewind(list *list, listIter *li)</td>
<td>设置li为前向迭代器</td>
<td>O(1)</td>
</tr>
<tr>
<td>listRewindTail(list *list, listIter *li)</td>
<td>设置li为尾向迭代器</td>
<td>O(1)</td>
</tr>
<tr>
<td>listRotateTailToHead(list *list)</td>
<td>将尾节点设置为头节点</td>
<td>O(1)</td>
</tr>
<tr>
<td>listRotateHeadToTail(list *list)</td>
<td>将头节点设置为尾节点</td>
<td>O(1)</td>
</tr>
<tr>
<td>listJoin(list *l, list *o)</td>
<td>将两个链表连接到一起</td>
<td>O(1)</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/01/computer%20science/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Z.J. Jiang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/01/computer%20science/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">Redis 内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-01 10:34:36" itemprop="dateCreated datePublished" datetime="2020-06-01T10:34:36+08:00">2020-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2020/06/01/computer%20science/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2020/06/01/computer%20science/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>Redis对内存管理进行啦封装，可以根据自己的实际情况选择不同的库对内存进行分配管理。Redis封装啦以下函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">zmalloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">zcalloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">zrealloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">zfree</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">zstrdup</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">zmalloc_used_memory</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">zmalloc_set_oom_handler</span><span class="params">(<span class="type">void</span> (*oom_handler)(<span class="type">size_t</span>))</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">zmalloc_get_rss</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">zmalloc_get_allocator_info</span><span class="params">(<span class="type">size_t</span> *allocated, <span class="type">size_t</span> *active, <span class="type">size_t</span> *resident)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">set_jemalloc_bg_thread</span><span class="params">(<span class="type">int</span> enable)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">jemalloc_purge</span><span class="params">()</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">zmalloc_get_private_dirty</span><span class="params">(<span class="type">long</span> pid)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">zmalloc_get_smap_bytes_by_field</span><span class="params">(<span class="type">char</span> *field, <span class="type">long</span> pid)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">zmalloc_get_memory_size</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">zlibc_free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br></pre></td></tr></table></figure>
<!---more--->
<h1 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h1><h2 id="zmalloc-default-oom"><a href="#zmalloc-default-oom" class="headerlink" title="zmalloc_default_oom"></a>zmalloc_default_oom</h2><p>oom表示out of memory.此函数在分配内存空间失败时打印错误信息。当然也可调用<strong>zmalloc_set_oom_handler</strong>使用自定义的错误输出函数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">zmalloc_default_oom</span><span class="params">(<span class="type">size_t</span> size)</span> {</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</span><br><span class="line">        size);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="内存统计函数"><a href="#内存统计函数" class="headerlink" title="内存统计函数"></a>内存统计函数</h2><p>内存统计函数使用一个全局变量used_memory来记录已开辟的内存。使用原子操作更新已使用内存值。__atomic_add_fetch是C++11支持的函数，如果没有的话则使用线程锁的方式。其中，_n&amp;(sizeof(long)-1) = _n % sizeof(long) - 1，用位操作来优化求余操作，之所要要这样，是因为内存需要对齐。值得注意的是这边的宏使用啦do{}while(0)的技巧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> update_zmalloc_stat_alloc(__n) do { \</span></span><br><span class="line"><span class="meta">    size_t _n = (__n); \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (_n&amp;(sizeof(long)-1)) _n += sizeof(long)-(_n&amp;(sizeof(long)-1)); \</span></span><br><span class="line"><span class="meta">    atomicIncr(used_memory,__n); \</span></span><br><span class="line"><span class="meta">} while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __atomic_add_fetch方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomicIncr(var,count) __atomic_add_fetch(&amp;var,(count),__ATOMIC_RELAXED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程锁的方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> atomicIncr(var,count) do { \</span></span><br><span class="line"><span class="meta">    pthread_mutex_lock(&amp;var ## _mutex); \</span></span><br><span class="line"><span class="meta">    var += (count); \</span></span><br><span class="line"><span class="meta">    pthread_mutex_unlock(&amp;var ## _mutex); \</span></span><br><span class="line"><span class="meta">} while(0)</span></span><br></pre></td></tr></table></figure>

<h2 id="zmalloc-zcolloc-zrealloc-zfree"><a href="#zmalloc-zcolloc-zrealloc-zfree" class="headerlink" title="zmalloc zcolloc zrealloc zfree"></a>zmalloc zcolloc zrealloc zfree</h2><p>zmalloc函数是malloc函数的封装，加上了一些错误处理和内存使用统计。同理zcolloc,zrealloc,zfree也是标准库函数的封装，加上错误处理和记录已分配内存的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">zmalloc</span><span class="params">(<span class="type">size_t</span> size)</span> {</span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    <span class="type">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="comment">// 更新状态</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    *((<span class="type">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="zstrup"><a href="#zstrup" class="headerlink" title="zstrup"></a>zstrup</h2><p>字符串复制函数，深拷贝！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">zstrdup</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> {</span><br><span class="line">    <span class="type">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> *p = zmalloc(l);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p,s,l);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="zmalloc-used-memory"><a href="#zmalloc-used-memory" class="headerlink" title="zmalloc_used_memory"></a>zmalloc_used_memory</h2><p>查询Redis已经开辟的内存空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">zmalloc_used_memory</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">size_t</span> um;</span><br><span class="line">    atomicGet(used_memory,um);</span><br><span class="line">    <span class="keyword">return</span> um;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="zmalloc-get-rss"><a href="#zmalloc-get-rss" class="headerlink" title="zmalloc_get_rss"></a>zmalloc_get_rss</h2><p>获得操作系统分配给redis的内存大小。rss(Resident Set Size)在/proc/pid号/stat 第第24个域。实际使用等于rss乘以一个页的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">zmalloc_get_rss</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">int</span> page = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="type">size_t</span> rss;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="type">char</span> filename[<span class="number">256</span>];</span><br><span class="line">    <span class="type">int</span> fd, count;</span><br><span class="line">    <span class="type">char</span> *p, *x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(filename,<span class="number">256</span>,<span class="string">"/proc/%d/stat"</span>,getpid());</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(filename,O_RDONLY)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (read(fd,buf,<span class="number">4096</span>) &lt;= <span class="number">0</span>) {</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    p = buf;</span><br><span class="line">    <span class="comment">// RSS 在proc/*/stat 下的第二十四个</span></span><br><span class="line">    count = <span class="number">23</span>; <span class="comment">/* RSS is the 24th field in /proc/&lt;pid&gt;/stat */</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; count--) {</span><br><span class="line">        p = <span class="built_in">strchr</span>(p,<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) p++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = <span class="built_in">strchr</span>(p,<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *x = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    rss = strtoll(p,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    rss *= page;</span><br><span class="line">    <span class="keyword">return</span> rss;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="zmalloc-get-memory-size"><a href="#zmalloc-get-memory-size" class="headerlink" title="zmalloc_get_memory_size"></a>zmalloc_get_memory_size</h2><p>得到物理内存的大小，直接读页数以及页大小， 相乘即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">zmalloc_get_memory_size</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">size_t</span>)sysconf(_SC_PHYS_PAGES) * (<span class="type">size_t</span>)sysconf(_SC_PAGESIZE);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h2 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h2><p>内存的各种信息， 在/proc/[pid]/smaps里面都可以查到， 比如上面的rss. /proc/self/smaps和/proc/[pid]/smaps完全等价。需要注意的一点是这里的单位是kb。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">zmalloc_get_smap_bytes_by_field</span><span class="params">(<span class="type">char</span> *field, <span class="type">long</span> pid)</span> {</span><br><span class="line">    <span class="type">char</span> line[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">size_t</span> bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flen = <span class="built_in">strlen</span>(field);</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) {</span><br><span class="line">        fp = fopen(<span class="string">"/proc/self/smaps"</span>,<span class="string">"r"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">char</span> filename[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(filename,<span class="keyword">sizeof</span>(filename),<span class="string">"/proc/%ld/smaps"</span>,pid);</span><br><span class="line">        fp = fopen(filename,<span class="string">"r"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fgets(line,<span class="keyword">sizeof</span>(line),fp) != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(line,field,flen) == <span class="number">0</span>) {</span><br><span class="line">            <span class="type">char</span> *p = <span class="built_in">strchr</span>(line,<span class="string">'k'</span>);</span><br><span class="line">            <span class="keyword">if</span> (p) {</span><br><span class="line">                *p = <span class="string">'\0'</span>;</span><br><span class="line">                bytes += strtol(line+flen,<span class="literal">NULL</span>,<span class="number">10</span>) * <span class="number">1024</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体来说，Redis的内存管理并不是很复杂，仅仅是对标准库的一些函数进行在一次的封装并增加了一些其他功能。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/31/computer%20science/Redis-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Z.J. Jiang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/31/computer%20science/Redis-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">Redis 简单动态字符串</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-31 23:21:27" itemprop="dateCreated datePublished" datetime="2020-05-31T23:21:27+08:00">2020-05-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2020/05/31/computer%20science/Redis-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2020/05/31/computer%20science/Redis-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h1><p>大体来说每个sdshdr表示一个SDS值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> {</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> {</span></span><br><span class="line">    <span class="type">uint8_t</span> len; </span><br><span class="line">    <span class="type">uint8_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> {</span></span><br><span class="line">    <span class="type">uint16_t</span> len; </span><br><span class="line">    <span class="type">uint16_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[]; </span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> {</span></span><br><span class="line">    <span class="type">uint32_t</span> len; </span><br><span class="line">    <span class="type">uint32_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> {</span></span><br><span class="line">    <span class="type">uint64_t</span> len; </span><br><span class="line">    <span class="type">uint64_t</span> alloc; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; </span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<!---more--->
<p>sdshdr有五种类型，根据数据的长度来选用适当的类型，其中sdshdr5并未使用，而且使用<strong>attribute((packed))<strong>来压缩空间（不使用对齐），避免空间的浪费。</strong>len</strong>用来记录<strong>buf</strong>的长度，<strong>alloc</strong>用来记录总共开辟的<strong>buf</strong>的大小。用<strong>flags</strong>来区分不同的sdshdr，flags被使用了3个bits，其他5个bits未被使用。值得注意的是，结构体中的<strong>char buf[]<strong>并不占用任何空间！例如，</strong>sizeof(sdshdr32) = 9</strong>。</p>
<h1 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h1><h2 id="获取字符串长度的效率不同"><a href="#获取字符串长度的效率不同" class="headerlink" title="获取字符串长度的效率不同"></a>获取字符串长度的效率不同</h2><ul>
<li>C标准库调用strlen函数获得字符串的长度，时间复杂度为<strong>O(n)</strong></li>
<li>SDS调用sdslen函数获取字符串长度，由于sdshdr有存储字符串长度，所以时间复杂度为<strong>O(1)</strong></li>
</ul>
<h2 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h2><p>C标准库API容易造成缓冲区溢出，例如，strcat(char *s, char *t)，把t字符串粘贴到s字符串的后面，C并不检测s剩余空间是否充足，而直接粘贴，这样当空间不足时就造成了缓冲区溢出。SDS在空间不足时会调用sdsMakeRomeFor函数先进行扩容操作，再把t字符串粘贴到s字符串后面。</p>
<h2 id="SDS的内存分配"><a href="#SDS的内存分配" class="headerlink" title="SDS的内存分配"></a>SDS的内存分配</h2><h3 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h3><p>SDS在调用sdsMakeRomeFor函数进行扩容时，如果需要扩容的空间小于1MB，那么<em>*newlen *= 2**，最终导致buf字符串和空闲空间各占一半。如果大于1MB，</em>*newlen += 1MB**。在空间小的时候，容量增长速度快，在空间很大的时候，容量保持1MB的线性增长。</p>
<h3 id="惰性释放"><a href="#惰性释放" class="headerlink" title="惰性释放"></a>惰性释放</h3><p>当SDS字符串缩短时，并不马上进行空间的释放，之后如果需要用到这些空间就不需要在分配空间。</p>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>SDS是根据len属性来判断长度的，所以不会出现像C语言一样提前遇到’\0’就结束字符串。SDS可以存储图片视频等任意二进制格式的文件。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>C字符串</th>
<th>SDS</th>
</tr>
</thead>
<tbody><tr>
<td>获取字符串长度的复杂度为O(N)</td>
<td>获取字符串长度的复杂度为O(1)</td>
</tr>
<tr>
<td>可能造成缓冲区溢出</td>
<td>不会造成缓冲区溢出</td>
</tr>
<tr>
<td>修改字符串长度N次必然需要执行N次内存重新分配</td>
<td>修改字符串长度N次最多需要执行N次内存重新分配</td>
</tr>
<tr>
<td>只能保存文本数据</td>
<td>可以保存文本或者二进制数据</td>
</tr>
<tr>
<td>可以使用所有&lt;string.h&gt;库中的字符串</td>
<td>可以使用部分&lt;string.h&gt;库中的字符串</td>
</tr>
</tbody></table>
<h1 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h1><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>sdsnew</td>
<td>创建一个新的sds字符串</td>
<td>O(N)</td>
</tr>
<tr>
<td>sdsempty</td>
<td>创建一个长度为0的sds字符串</td>
<td>O(1)</td>
</tr>
<tr>
<td>sdsup</td>
<td>复制一个sds字符串</td>
<td>O(N)</td>
</tr>
<tr>
<td>sdsfree</td>
<td>释放整个sds结构体</td>
<td>O(N)</td>
</tr>
<tr>
<td>sdsclear</td>
<td>清空sds字符串</td>
<td>O(1)</td>
</tr>
<tr>
<td>sdsMakeRoomFor</td>
<td>根据特定的策略扩容</td>
<td>NULL</td>
</tr>
<tr>
<td>sdsRemoveFreeSpace</td>
<td>释放buf中空闲的空间</td>
<td>视情况而定</td>
</tr>
<tr>
<td>sdsAllocSize</td>
<td>得到sdshdr的空间大小(包括buf)</td>
<td>O(1)</td>
</tr>
<tr>
<td>sdsAllocPtr</td>
<td>得到sdshdr结构体的首地址</td>
<td>O(1)</td>
</tr>
<tr>
<td>sdsIncLen</td>
<td>把incr后的位置设置为\0，并更新sds的len，len+=incr</td>
<td>O(1)</td>
</tr>
<tr>
<td>sdsgrowzero</td>
<td>以0填充扩容sds字符串</td>
<td>O(len),len为函数的参数</td>
</tr>
<tr>
<td>sdscat</td>
<td>把t复制到s后面</td>
<td>O(len),len为t的长度</td>
</tr>
<tr>
<td>sdscpy</td>
<td>用t替换s</td>
<td>O(len),len为t的长度</td>
</tr>
<tr>
<td>sdsll2str</td>
<td>把long long 类型的数转成sds</td>
<td>需要特定的计算</td>
</tr>
<tr>
<td>sdscatprintf</td>
<td>类似sprintf(s,”%d”, 10), 格式化到s中</td>
<td>NULL</td>
</tr>
<tr>
<td>sdstrim</td>
<td>去除sds中连续出现的cset中的字符</td>
<td>视情况而定</td>
</tr>
<tr>
<td>sdscmp</td>
<td>比较两个sds字符串</td>
<td>O(N),N是比较的长度</td>
</tr>
<tr>
<td>sdssplitlen</td>
<td>根据特定的分割符拆分字符串</td>
<td>NULL</td>
</tr>
<tr>
<td>sdsjoin</td>
<td>根据分割符将字符串连接到一起</td>
<td>NULL</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/28/computer%20science/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Z.J. Jiang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/28/computer%20science/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">linux网络编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-28 09:55:13" itemprop="dateCreated datePublished" datetime="2020-05-28T09:55:13+08:00">2020-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2020/05/28/computer%20science/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2020/05/28/computer%20science/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><h2 id="网络应用程序设计模式："><a href="#网络应用程序设计模式：" class="headerlink" title="网络应用程序设计模式："></a>网络应用程序设计模式：</h2><ul>
<li>C/S-client/server<ul>
<li>优点：1.协议选用灵活 2.可以缓存数据</li>
<li>缺点: 1.对用户安全构成威胁 2.开发工作量大，调试困难</li>
</ul>
</li>
<li>B/S-browser/server<ul>
<li>优点：跨平台</li>
<li>缺点：只能使用http<!---more---></li>
</ul>
</li>
</ul>
<h2 id="协议的概念"><a href="#协议的概念" class="headerlink" title="协议的概念"></a>协议的概念</h2><ul>
<li>规则：数据下输和数据解释的规则</li>
<li>原始协议—-&gt;(改进、完善)—-&gt;标准协议</li>
<li>典型协议：<strong>TCP/UDP</strong> HTTP FTP <strong>IP</strong> <strong>ARP（根据IP得到MAC地址）</strong></li>
</ul>
<h2 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h2><ul>
<li>7层模型-OSI:<ul>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ul>
</li>
<li>TCP/IP四层模型<ul>
<li>数据链路层 – 以太网桢协议、ARP</li>
<li>网络层 – IP、ICMP、IGMP</li>
<li>传输层 – tcp、udp</li>
<li>应用层 – ftp、http、ssh</li>
</ul>
</li>
</ul>
<p>一层一层封装，将传输的数据封装起来。</p>
<p>网络传输流程：<br>数据没有封装之前，是不能在网络中传递的。</p>
<h2 id="以太网帧协议。"><a href="#以太网帧协议。" class="headerlink" title="以太网帧协议。"></a>以太网帧协议。</h2><p>  ARP:协议，根据IP地址获取MAC<br>  以太网帧协议: 根据MAC地址，完成数据包传输。</p>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>  IPv4，IPv6<br>  TTL: time to live。设置数据包在路由节点的跳转上限。每经过一个路由节点，减一，。到达条件之后丢弃。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>  IP地址：IP地址可以在网络中唯一标识一台主机。</p>
<h2 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h2><ul>
<li>面向链接的安全的流式传输协议</li>
<li>连接的时候进行三次握手</li>
<li>数据发送的时候，会进行数据确认</li>
<li>数据丢失之后，会进行数据重传</li>
</ul>
<h2 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h2><ul>
<li>面向无连接的不安全的报式传输</li>
<li>连接的时候不会握手</li>
<li>数据发送出去之后就不管了</li>
<li>如果数据包丢失会全丢 不存在丢失一半的情况</li>
</ul>
<h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><ul>
<li>网络IO编程:读写操作,创建一个套接字，得到的是文件描述符.fd操作的是一块内核缓冲区</li>
<li>什么是socket:<br>网络通信的函数接口,<br>封装了传输层协议,<br>  tcp<br>  udp</li>
<li>浏览器-http:<br>封装的是tcp</li>
</ul>
<h3 id="套接字的概念"><a href="#套接字的概念" class="headerlink" title="套接字的概念"></a>套接字的概念</h3><ul>
<li>IP地址</li>
<li>端口号</li>
<li>IP+Port</li>
</ul>
<h3 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h3><ul>
<li>大端</li>
<li>小端</li>
</ul>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">文件（内核的缓冲区）操作</span><br><span class="line">socket tcp server</span><br><span class="line">  创建套接字</span><br><span class="line">    <span class="type">int</span> lfd = socket</span><br><span class="line">  绑定本地IP和端口</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in serv;</span><br><span class="line">    serv.port = htons(port)</span><br><span class="line">    serv.IP = htonl(INADDR_ANY)</span><br><span class="line">    bind(lfd, &amp;serv, <span class="keyword">sizeof</span>(serv));</span><br><span class="line">  **设置监听上限**</span><br><span class="line">    listen(lfd, <span class="number">128</span>);</span><br><span class="line">  等待接收连接请求</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(client)</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, &amp;client, &amp;len)</span><br><span class="line">      cfd-用于通信的</span><br><span class="line">  通信</span><br><span class="line">    接收数据：read/recv</span><br><span class="line">    发送数据：write/send</span><br><span class="line">  关闭：</span><br><span class="line">    close(lfd)</span><br><span class="line">    close(cfd)</span><br><span class="line">客户端</span><br><span class="line">  创建套接字</span><br><span class="line">    <span class="type">int</span> fd = socket</span><br><span class="line">  连接服务器</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in server;</span><br><span class="line">    server.port</span><br><span class="line">    server.ip = <span class="type">int</span>  ?????</span><br><span class="line">    server.family</span><br><span class="line">    connect（fd, &amp;server, <span class="keyword">sizeof</span>(server));</span><br><span class="line">  通信</span><br><span class="line">    接收数据：read/recv</span><br><span class="line">    发送数据：write/send</span><br><span class="line">  断开链接</span><br><span class="line">    close(fd);</span><br></pre></td></tr></table></figure>

<p>man 7 ip</p>
<h3 id="tcp-三次握手"><a href="#tcp-三次握手" class="headerlink" title="tcp 三次握手"></a>tcp 三次握手</h3><ul>
<li>第一次握手<ul>
<li>客户端：携带标志位：SYN，随机产生32位序号</li>
<li>服务器：检测SYN的值是否为1,</li>
</ul>
</li>
<li>第二次握手<ul>
<li>服务器：ACK标志位+确认序号（客户端随机序号+1），发起一个链接请求SYN+32随机需要</li>
<li>客户端：检测标志位，校验确认需要是否正确</li>
</ul>
</li>
<li>第三次握手<ul>
<li>客户端：<br>  发送确认数据包 ACK+服务器的随机序号+1</li>
<li>服务器：<br>  检测ACK是否为1,校验确认序号是否正确。</li>
</ul>
</li>
</ul>
<h3 id="tcp-四次挥手"><a href="#tcp-四次挥手" class="headerlink" title="tcp 四次挥手"></a>tcp 四次挥手</h3><ul>
<li>第一次挥手<ul>
<li>客户端:<br>发送断开连接的请求<br>  FIN + 序号<br>  ACK + 序号</li>
<li>服务器:<br>检测FIN值是否为1,<br>ack的作用告诉对方之前发的数据收到了多少</li>
</ul>
</li>
<li>第二次挥手<ul>
<li>服务器:<br>给client确认的数据包,<br>  ACK + 确认的编号,<br>FIN对应的序号+1+携带数据大小</li>
<li>客户端：<br>检测：ACK值<br>检测确认序号</li>
</ul>
</li>
<li>第三次挥手<ul>
<li>服务器端：<br>发送断开链接的请求<br>  FIN + 序号<br>  ACK + 序号</li>
<li>客户端：<br>数据检测</li>
</ul>
</li>
<li>第四次挥手:<br>断开连接:<br>服务器 close<br>客户端 close</li>
</ul>
<h2 id="使用多进程的方式，解决服务器处理多连接的问题"><a href="#使用多进程的方式，解决服务器处理多连接的问题" class="headerlink" title="使用多进程的方式，解决服务器处理多连接的问题"></a>使用多进程的方式，解决服务器处理多连接的问题</h2><ul>
<li>共享<ul>
<li>读时共享，写时复制</li>
<li>文件描述符</li>
<li>内存映射区 – mmap</li>
</ul>
</li>
<li>父进程的角色是什么？<ul>
<li>等待接受客户端连接 – accept<ul>
<li>有连接<ul>
<li>创建一个子进程 fork</li>
</ul>
</li>
<li>将通信的文件描述符关闭<ul>
<li>浪费资源</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>子进程的角色是什么？<ul>
<li>通信<ul>
<li>使用accept返回值 -fd</li>
</ul>
</li>
<li>关掉监听的文件描述符<ul>
<li>浪费资源</li>
</ul>
</li>
</ul>
</li>
<li>创建的进程的个数有限制吗？<ul>
<li>硬件限制</li>
<li>文件描述符默认也是有上限的1024</li>
</ul>
</li>
<li>子进程资源回收<ul>
<li>wait/waitpid</li>
<li>使用信号回收<ul>
<li>signal</li>
<li>sigaction-推荐(信号捕捉)</li>
</ul>
</li>
<li>捕捉信号: SIGCHLD</li>
</ul>
</li>
</ul>
<h2 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL"></a>2MSL</h2><h2 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h2><ul>
<li>A给B发送是FIN（A调用close函数），但是B没有给A发送FIN（B没有调用close）</li>
<li>A断开了与B的连接，B没有断开与A的连接</li>
<li>特点：<br>A不能给B发送数据，A可以收B发送的数据<br>B可以给A发送数据，<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">函数：<span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br><span class="line">  sockfd: 要半关闭的一方对应的文件描述符(不管dup,dup2多少次，可以全部关闭)</span><br><span class="line">  通信的文件描述符</span><br><span class="line">  how:</span><br><span class="line">    SHUT_RD</span><br><span class="line">    SHUT_WR</span><br><span class="line">    SHUT_RDWR</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h2><ul>
<li><p>端口复用最常用的用途是：<br>防止服务器重启时之前绑定的端口还未释放<br>程序突然退出二系统没有释放端口</p>
</li>
<li><p>设置方法</p>
<p>int opt<br>setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const void*)&amp;opt, sizeof(opt))</p>
</li>
<li><p>注意事项：<br>绑定之前设置</p>
</li>
</ul>
<h3 id="IO操作方式"><a href="#IO操作方式" class="headerlink" title="IO操作方式"></a>IO操作方式</h3><ul>
<li><p>阻塞等待<br>好处: 不占用CPU宝贵时间片<br>缺点: 同一时刻只能处理一个操作，效率低<br>多线程和多进程</p>
</li>
<li><p>非阻塞，忙轮询<br>优点：提高程序的执行效率<br>缺点：需要占用更多的CPU和系统资源</p>
</li>
<li><p>使用IO多路转接技术 select/poll/epoll （我觉得其实就是 代理委托给内核）</p>
<ul>
<li>select/poll<br>  select代收员比较懒，她只会告诉你有几个快递到了，但是那个快递，你需要挨个遍历一遍（委托内核）</li>
<li>epoll<br>  epoll代收快递员很勤快，她不仅会告诉你有几个快递到了，还会告诉你是那个快递公司的快递</li>
</ul>
</li>
</ul>
<h3 id="什么是I-O多路转接技术"><a href="#什么是I-O多路转接技术" class="headerlink" title="什么是I/O多路转接技术"></a>什么是I/O多路转接技术</h3><p>  先构造一张有关文件描述符的列表，将要监听的文件描述符添加到列表中<br>  然后调用一个函数，监听该表中的文件描述符，知道这些描述符表中的一个进行I/O操作，该函数才返回<br>    该函数为阻塞函数<br>    函数对文件描述符的检测操作是由内核完成的<br>  在返回时，它告诉进程有多少（哪些）描述符要进行I/O操作</p>
<h3 id="IO多路转接-select"><a href="#IO多路转接-select" class="headerlink" title="IO多路转接 select"></a>IO多路转接 select</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">函数原型</span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span> <span class="params">(</span></span><br><span class="line"><span class="params">      <span class="type">int</span> nfds<span class="comment">// 要检测的文件描述符中最大的fd+1 - 1024 最大只能是1024</span></span></span><br><span class="line"><span class="params">      **fd_set *readfds**, <span class="comment">// 读集合 传入传出参数</span></span></span><br><span class="line"><span class="params">      fd_set *writefds, <span class="comment">// 写集合</span></span></span><br><span class="line"><span class="params">      fd_set *excepfds, <span class="comment">// 异常集合</span></span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> timeval *timeout;</span></span><br><span class="line"><span class="params">        <span class="literal">NULL</span>: 永久阻塞</span></span><br><span class="line"><span class="params">          当检测到fd变化的时候返回</span></span><br><span class="line"><span class="params">        timeval a</span></span><br><span class="line"><span class="params">          a.tv_sec = <span class="number">10</span>;</span></span><br><span class="line"><span class="params">          a.tv_sec = <span class="number">0</span>;</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line">  <span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set* <span class="built_in">set</span>)</span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set* <span class="built_in">set</span>)</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> lfd = socket()</span><br><span class="line">  bind()</span><br><span class="line">  listen()</span><br><span class="line">  <span class="comment">// 创建一个文件描述符表</span></span><br><span class="line">  fd_set reads, temp</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  fd_zero(&amp;reads)</span><br><span class="line">  <span class="comment">// 监听的lfd加入到读集合</span></span><br><span class="line">  fd_set(lfd, &amp;reads)</span><br><span class="line">  <span class="type">int</span> maxfd = lfd;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  {</span><br><span class="line">    <span class="comment">// 委托内核检测</span></span><br><span class="line">    temp = reads;</span><br><span class="line">    <span class="type">int</span> ret = select(maxfd+<span class="number">1</span>,</span><br><span class="line">      &amp;reads, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是不是监听的， 有没有新的链接到达</span></span><br><span class="line">    <span class="keyword">if</span>(fd_isset(lfd, &amp;temp))</span><br><span class="line">    {</span><br><span class="line">      <span class="comment">// 接收新连接</span></span><br><span class="line">      <span class="type">int</span> cfd = accept();</span><br><span class="line">      <span class="comment">// cfd加入到读集合‘</span></span><br><span class="line">      fd_set(cfd, &amp;reads)</span><br><span class="line">      <span class="comment">// 跟新maxfd</span></span><br><span class="line">      maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 客户端发送数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=lfd+<span class="number">1</span>; i&lt;=maxfd; ++i)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(fd_isset(i, &amp;temp))</span><br><span class="line">      {</span><br><span class="line">        <span class="type">int</span> len = read()</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">          <span class="comment">// cfd从读集合中删除</span></span><br><span class="line">          fd_clr(i, &amp;reads);</span><br><span class="line">        }</span><br><span class="line">        write()</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="使用select函数的优缺点"><a href="#使用select函数的优缺点" class="headerlink" title="使用select函数的优缺点"></a>使用select函数的优缺点</h4><ul>
<li>优点<br>跨平台</li>
<li>缺点<br>每次调用select 都需要吧fd集合从用户态拷贝到内核态<br>这个开销在fd很多时会很大<br>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大<br>select支持的文件描述符数量太小了，默认是1024</li>
</ul>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fd, <span class="type">nfd_t</span> nfds, <span class="type">int</span> timeout)</span></span><br><span class="line">  pollfd: 数组的地址</span><br><span class="line">  nfds:数组的最大长度，数组中最后一个使用的元素下表+1</span><br><span class="line">    内核会轮询检测fd数组的每个文件描述符</span><br><span class="line"><span class="keyword">struct</span> pollfd {</span><br><span class="line">  <span class="type">int</span> fd;     <span class="comment">// 文件描述符</span></span><br><span class="line">  <span class="type">short</span> events; <span class="comment">// 等待的事件</span></span><br><span class="line">  <span class="type">short</span> revents; <span class="comment">// 实际发生的时间、 内核给的反馈k</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>


<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">三个函数</span><br><span class="line">  该函数生成一个epoll专用的文件描述符</span><br><span class="line">  <span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span><br><span class="line">    size:epoll上能关注的最大描述符数</span><br><span class="line">  用于控制某个epoll文件描述符时间，可以注册，修改、删除</span><br><span class="line">    <span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line">    epfd: epoll_create 生成的epoll专用描述粗</span><br><span class="line">    op</span><br><span class="line">      EPOLL_CTL_ADD 注册</span><br><span class="line">      EPOLL_CTL_MOD 修改</span><br><span class="line">      EPOLL_CTL_DEL 删除</span><br><span class="line">    fd: 关联的文件描述符</span><br><span class="line">    event: 告诉内核要监听什么时间</span><br><span class="line">  等待IO事件发生-可以设置阻塞的函数</span><br><span class="line">  <span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event* events,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maxevents,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> timeout</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">  对应select 和poll函数</span><br><span class="line">  参数：</span><br><span class="line">    epfd:要检测的句柄</span><br><span class="line">    events:用于回传待处理事件的数组</span><br><span class="line">    maxevents: 告诉内核这个events的大小</span><br><span class="line">    timeout: 为超时时间</span><br><span class="line">      -1 永久阻塞</span><br><span class="line">      0 立即返回</span><br><span class="line">      &gt;0 为所设置的时间</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data {</span><br><span class="line">  <span class="type">void</span> *ptr;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="type">uint32_t</span> u32;</span><br><span class="line">  <span class="type">uint64_t</span> u64;</span><br><span class="line">}<span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> {</span></span><br><span class="line">  <span class="type">uint32_t</span> events;</span><br><span class="line">  <span class="type">epoll_data_t</span> data;</span><br><span class="line">}</span><br><span class="line">events:</span><br><span class="line">  EPOLLIN 读</span><br><span class="line">  EPOLLOUT 写</span><br><span class="line">  EPOLLERR 异常</span><br><span class="line"></span><br><span class="line">  epoll 模型</span><br><span class="line">  <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">  {</span><br><span class="line">    <span class="type">int</span> lfd = socket();</span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind();</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen()</span><br><span class="line">    <span class="comment">// epoll 数根节点</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">3000</span>);</span><br><span class="line">    <span class="comment">// 存储发送变化的fd对应信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">all</span>[3000];</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 监听的lfd挂到epoll数上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="comment">// 在ev中 init lfd信息</span></span><br><span class="line">    ev.events = EPOLLIN</span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev)</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">      <span class="comment">// 委托内核检测事件</span></span><br><span class="line">      <span class="type">int</span> ret = epoll_wait(epfd, all, <span class="number">3000</span>, <span class="number">-1</span>);</span><br><span class="line">      <span class="comment">// 根据ret遍历all数组</span></span><br><span class="line">      fork（<span class="type">int</span> i=<span class="number">0</span>; i&lt;ret; ++i)</span><br><span class="line">      {</span><br><span class="line">        <span class="type">int</span> fd = all[i].data.fd;</span><br><span class="line">        <span class="comment">// 有新的链接</span></span><br><span class="line">        <span class="keyword">if</span>(fd == lfd)</span><br><span class="line">        {</span><br><span class="line">          <span class="comment">// 接收连接请求  accept不阻塞</span></span><br><span class="line">          <span class="type">int</span> cfd = accept();</span><br><span class="line">          <span class="comment">// cfd 挂到epoll数上</span></span><br><span class="line">          ev.events = EPILLIN</span><br><span class="line">          ev.data = cfd;</span><br><span class="line">          epoll_Ctl(epfd, epoll_ctl_...)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">          <span class="comment">// 只处理客户端发来的数据</span></span><br><span class="line">          <span class="keyword">if</span>(!all[i].events &amp; EPOLLIN)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 读数据</span></span><br><span class="line">            recv</span><br><span class="line">            <span class="title function_">if</span><span class="params">(len == <span class="number">0</span>)</span></span><br><span class="line">            {</span><br><span class="line">              close(fd);</span><br><span class="line">              epoll_ctl_del</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 写数据</span></span><br><span class="line">            send()</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经链接的客户端有数据发送过来</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></table></figure>

<h4 id="epoll-三种工作模式"><a href="#epoll-三种工作模式" class="headerlink" title="epoll 三种工作模式"></a>epoll 三种工作模式</h4><ol>
<li>水平触发模式-根据读来解释</li>
</ol>
<ul>
<li>只要fd对应的缓冲区有树</li>
<li>epoll_wait 返回</li>
<li>返回的次数与发送数据的次数没有关系</li>
<li>epoll默认的工作模式</li>
</ul>
<ol start="2">
<li>边沿触发模式-ET （边沿阻塞）</li>
</ol>
<ul>
<li>fd - 阻塞属性</li>
<li>客户端给server发数据<br>发一次数据server的epoll_wait返回一次<br>不在乎数据是否读完<br>如果读不完，如何全部读出来<br>  while(recv());<br>数据读完之后recv会阻塞<br>解决阻塞问题<br>  设置非阻塞</li>
</ul>
<ol start="3">
<li>边沿非阻塞触发<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">   效率最高</span><br><span class="line">   如何设置非阻塞</span><br><span class="line">   可以突破<span class="number">1024</span>个的文件描述符</span><br><span class="line">缺点：</span><br><span class="line">  不能跨平台。Linux</span><br><span class="line">    <span class="title function_">open</span><span class="params">()</span></span><br><span class="line">      设置flags</span><br><span class="line">      必须 O_WDRW | ONONBLOCK</span><br><span class="line">      终端文件: /dev/tty</span><br><span class="line">    fcntl</span><br><span class="line">      <span class="type">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line">      flag |= O_NONBLOCK <span class="comment">// 修改文件描述符</span></span><br><span class="line">      fcntl(fd, F_SETFL, flag);</span><br><span class="line">   将缓冲区的全部数据都读出来</span><br><span class="line">    <span class="keyword">while</span>(recv() &gt; <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      <span class="built_in">printf</span>();</span><br><span class="line">    }</span><br><span class="line">    当缓冲区数据读完，是否返回<span class="number">0</span>???</span><br><span class="line"></span><br><span class="line">    阻塞</span><br><span class="line">      数据读完之后</span><br><span class="line">    非阻塞</span><br><span class="line">      强行读了一个没有数据的缓冲区(fd)</span><br><span class="line">      判断errno == EAGIAN</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="文件描述符突破1024限制"><a href="#文件描述符突破1024限制" class="headerlink" title="文件描述符突破1024限制"></a>文件描述符突破1024限制</h4><ul>
<li><p>select 突破不了，需要重新编译内核</p>
</li>
<li><p>poll和epoll可以突破1024限制</p>
</li>
<li><p>查看计算硬件限制的文件描述符上线</p>
<ul>
<li>cat /proc/sys/fs/maxfd</li>
</ul>
</li>
<li><p>修改</p>
<ul>
<li>/etc</li>
</ul>
</li>
</ul>
<h2 id="UDP通信流程"><a href="#UDP通信流程" class="headerlink" title="UDP通信流程"></a>UDP通信流程</h2><ul>
<li>server<ul>
<li>创建套接字</li>
<li>绑定本地IP和端口</li>
<li>通信</li>
<li>recvfrom() 会保存client的IP和端口</li>
<li>关闭套接字</li>
</ul>
</li>
</ul>
<h2 id="tcp-udp-使用场景"><a href="#tcp-udp-使用场景" class="headerlink" title="tcp udp 使用场景"></a>tcp udp 使用场景</h2><ul>
<li><p>tcp 使用场景</p>
<ul>
<li>对数据安全性安全要求高的时候<ul>
<li>登录数据的传输</li>
<li>文件传输</li>
</ul>
</li>
<li>http协议<ul>
<li>传输层协议-tcp</li>
</ul>
</li>
</ul>
</li>
<li><p>udp使用场景</p>
<ul>
<li>效率高-实时性要求比较高<ul>
<li>视频聊天</li>
<li>通话</li>
</ul>
</li>
<li>有实力的大公司<ul>
<li>使用udp<ul>
<li>在应用层自定义协议，做数据校验！！！（保证UDP的不丢失）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><ul>
<li>服务器<ul>
<li>创建套接字-socket</li>
<li>fd绑定服务器IP和端口</li>
<li>初始化客户端IP和端口信息<ul>
<li>struct  sockaddr_in cli;</li>
<li>cli.sin_family = af_inet;</li>
<li>cli.port = htons(8888)</li>
<li>inet_pton(af_inet, “IP必须是广播IP”, &amp;cli.adr);</li>
</ul>
</li>
<li>发送数据<ul>
<li>sendto(fd, buf, len, 0, )</li>
</ul>
</li>
<li>设置广播权限<ul>
<li>setsockopt();</li>
</ul>
</li>
</ul>
</li>
<li>客户端<ul>
<li>创建套接字</li>
<li>显示绑定端口<ul>
<li>bind()</li>
</ul>
</li>
<li>接收数据 - server数据<ul>
<li>recvfrom();</li>
</ul>
</li>
</ul>
</li>
<li>使用范围<ul>
<li>只适用于局域网</li>
</ul>
</li>
</ul>
<h2 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h2><ul>
<li><p>使用范围</p>
<ul>
<li>局域网</li>
<li>Internet</li>
</ul>
</li>
<li><p>sever:</p>
<ul>
<li>需要使用组播地址</li>
<li>发送到客户端对应的端口上</li>
<li>添加组播权限</li>
</ul>
</li>
<li><p>client:</p>
<ul>
<li>绑定固定端口</li>
<li>加入到组播地址</li>
</ul>
</li>
</ul>
<h2 id="本地套接字完成没有血缘关系的进程间的通信"><a href="#本地套接字完成没有血缘关系的进程间的通信" class="headerlink" title="本地套接字完成没有血缘关系的进程间的通信"></a>本地套接字完成没有血缘关系的进程间的通信</h2><ol>
<li>文件格式</li>
</ol>
<ul>
<li>管道:p</li>
<li>套接字：s<ul>
<li>伪文件</li>
</ul>
</li>
</ul>
<ol start="2">
<li>服务器端</li>
</ol>
<ul>
<li>创建套接字<ul>
<li>int fd = socket(AF_LOCAL, sock_stream, 0);</li>
</ul>
</li>
<li>绑定<ul>
<li>struct sockaddr_un serv;</li>
<li>serv.sun_family = af_local</li>
<li>strcpy(serv.sun_path, “server.socket”);</li>
<li>bind(lfd, (struct sockaddr&amp;)&amp;serv, len); // 绑定成功文件就创建出来了</li>
</ul>
</li>
<li>设置监听<ul>
<li>listen</li>
</ul>
</li>
<li>等待链接请求<ul>
<li>struct sockaddr_un client;</li>
<li>int len = sizeof(client)</li>
<li>int cfd = accept(lfd, &amp;client, &amp;len);</li>
</ul>
</li>
<li>通信<ul>
<li>send</li>
<li>recv</li>
</ul>
</li>
<li>断开连接<ul>
<li>close(cfd)</li>
<li>close(lfd)</li>
</ul>
</li>
</ul>
<ol start="3">
<li>客户端</li>
</ol>
<ul>
<li>创建套接字<ul>
<li>int fd = socket(af_local, sock_stream, 0)</li>
</ul>
</li>
<li>绑定一个套接字文件<ul>
<li>struct sockaddr_un client;</li>
<li>client.sun_family = af_local;</li>
<li>strcpy(client.sun_paht, “client.socket”);</li>
<li>bind(fd, (struct sockaddr*)&amp;client, len)</li>
</ul>
</li>
<li>链接服务器<ul>
<li>struct sockaddr_un serv;</li>
<li>serv.sun_family = af_local</li>
<li>strcpy(serv.sun_path, “server.socket”);</li>
<li>connect(fd, &amp;serv, sizeof(serv))</li>
</ul>
</li>
<li>通信<ul>
<li>recv</li>
<li>send</li>
</ul>
</li>
<li>关闭<ul>
<li>close</li>
</ul>
</li>
</ul>
<h2 id="心跳包"><a href="#心跳包" class="headerlink" title="心跳包"></a>心跳包</h2><ul>
<li>判断客户端和服务器是否处于链接状态<ul>
<li>心跳状态<ul>
<li>不会携带大量的数据</li>
<li>每个一定时间服务器-&gt;客户端/客户端-&gt;服务器发送一个心跳包</li>
</ul>
</li>
<li>心跳包看成一个协议<ul>
<li>应用层协议</li>
</ul>
</li>
<li>判断网络是否断开<ul>
<li>有多个连续的心跳包没收到/没有回复</li>
<li>关闭通信的套接字</li>
</ul>
</li>
<li>重连<ul>
<li>重新初始套接字</li>
<li>继续发送心跳包</li>
</ul>
</li>
</ul>
</li>
<li>乒乓包<ul>
<li>比心跳包携带的数据多一些</li>
<li>除了知道连接是否存在，还能获取一些信息</li>
</ul>
</li>
</ul>
<h1 id="libevent"><a href="#libevent" class="headerlink" title="libevent"></a>libevent</h1><h2 id="事件的底层处理框架"><a href="#事件的底层处理框架" class="headerlink" title="事件的底层处理框架"></a>事件的底层处理框架</h2><p>  一个函数</p>
<h2 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h2><p>  一个函数</p>
<h2 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h2><p>  不带缓冲区的-event<br>    几个函数<br>  带缓冲区-bufferevent<br>    几个函数</p>
<h2 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h2><p>  几个函数</p>
<h2 id="libevent是干什么的"><a href="#libevent是干什么的" class="headerlink" title="libevent是干什么的"></a>libevent是干什么的</h2><ul>
<li>开源的库，提高开发效率<ul>
<li>封装了socket通信</li>
<li>封装了IO多路转接</li>
</ul>
</li>
<li>精简，专注于网络，性能高</li>
<li>事件驱动</li>
</ul>
<h2 id="使用套路"><a href="#使用套路" class="headerlink" title="使用套路"></a>使用套路</h2><ul>
<li>创建一个事件处理框架</li>
<li>创建一个时间</li>
<li>事件添加到事件处理框架上</li>
<li>开始事件循环</li>
<li>释放资源</li>
</ul>
<h2 id="事件处理框架-event-base"><a href="#事件处理框架-event-base" class="headerlink" title="事件处理框架-event_base"></a>事件处理框架-event_base</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、使用libevent函数之前需要分配一个或者多个event_base结构体</span><br><span class="line"><span class="number">2</span>、创建event_base_new(<span class="type">void</span>);</span><br><span class="line">  释放event_base_free()</span><br><span class="line">  循环监听event_base_dispatch();事件循环</span><br><span class="line"><span class="number">3</span></span><br><span class="line">  查看event_base封装的后端</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>** <span class="title function_">event_get_supported_methods</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* <span class="title function_">event_base_get_method</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> event_base* base)</span>;</span><br><span class="line"></span><br><span class="line">  event_base 和 fork</span><br><span class="line">    子进程创建成功之后，父进程可以继续使用event_base</span><br><span class="line">    子进程需要继续使用event_base需要重新初始化</span><br><span class="line">      event_reinit(base);</span><br><span class="line">  event_base_new</span><br><span class="line">  event_new</span><br><span class="line">  event_free</span><br><span class="line">  event_add</span><br></pre></td></tr></table></figure>


<h2 id="bufferevent-理解"><a href="#bufferevent-理解" class="headerlink" title="bufferevent 理解"></a>bufferevent 理解</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">是libevent为IO缓冲区操作提供的一种通用机制</span><br><span class="line">bufferevent由一个底层的传输端口（如套接字—），一个读取换红区和一个写入缓冲区组成</span><br><span class="line">与通常</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、创建基于套接字的bufferevent</span><br><span class="line">  bufferevent_socket_new</span><br><span class="line">释放</span><br><span class="line">  bufferevent_free</span><br><span class="line">  bufferevent_setcb : 设置回调</span><br><span class="line">  bufferevent_write</span><br><span class="line">  bufferevent_read</span><br><span class="line">  bufferevent_enable</span><br><span class="line">  bufferevent_disable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在bufferevent上启动链接</span><br><span class="line">  bufferevent_socket_connect()</span><br><span class="line"></span><br><span class="line">链接监听器 evconnlistener</span><br><span class="line"></span><br><span class="line">server端evconnlistener_new_bind() <span class="comment">// 直接一步到位</span></span><br><span class="line">创建监听的套接字</span><br><span class="line">绑定</span><br><span class="line">监听</span><br><span class="line">接收连接请求</span><br><span class="line"><span class="keyword">struct</span> <span class="title function_">evconnlistener_new_bind</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> event_base *base,</span></span><br><span class="line"><span class="params">    evconnlistener_cb cb 接收链接之后，用户需要做什么j</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *ptr, <span class="comment">// 回调函数</span></span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> flags,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> backlog,</span></span><br><span class="line"><span class="params">      <span class="number">-1</span> 使用的默认的最大值</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa,</span></span><br><span class="line"><span class="params">      服务器的IP和端口信息</span></span><br><span class="line"><span class="params">    <span class="type">int</span> socklen</span></span><br><span class="line"><span class="params">  )</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Z.J. Jiang</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">209k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:48</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"libUrl":"https://unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/page/2/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
