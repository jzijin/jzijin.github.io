<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="computer science">
<meta property="og:type" content="website">
<meta property="og:title" content="SRCNN">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="SRCNN">
<meta property="og:description" content="computer science">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="srcnn">
<meta property="article:tag" content="computer science">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SRCNN</title>
  







<link rel="dns-prefetch" href="https://waline.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SRCNN</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">2</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">13</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">51</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="srcnn"
      src="https://srcnn-blog.oss-cn-hangzhou.aliyuncs.com/2023-10-06-15-57-57_0d920927.png">
  <p class="site-author-name" itemprop="name">srcnn</p>
  <div class="site-description" itemprop="description">computer science</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/jzijin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jzijin" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/06/computer_science/STM32/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://srcnn-blog.oss-cn-hangzhou.aliyuncs.com/2023-10-06-15-57-57_0d920927.png">
      <meta itemprop="name" content="srcnn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/06/computer_science/STM32/" class="post-title-link" itemprop="url">STM32</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-06 00:30:15" itemprop="dateCreated datePublished" datetime="2022-03-06T00:30:15+08:00">2022-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2022/03/06/computer_science/STM32/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2022/03/06/computer_science/STM32/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>讲解<br>外设原理+器件原理+ST官方参考手册+ST标准库 &#x3D; 外设开发</p>
<p>HAL库。</p>
<ul>
<li>开发板的介绍</li>
<li>视频思路的讲解。</li>
</ul>
<p>全功能开发板<br>电机开发板</p>
<p>ARM：芯片内核设计公司<br>Advanced RISC Machines</p>
<p>Cortex M4<br>RGB-LGBT</p>
<p>Cortex M7<br>STM32 - ST公司</p>
<p>电机开发板系列</p>
<p>HAL库： 硬件抽象层<br>抽象思想<br>封装出一层通用性的接口，标准化了一套初始化和使用流程，大大提高了代码的通用性。<br>GPIO: function() -&gt; F1\F4\F7\H7</p>
<p>MIddle level</p>
<p>CubeMX 只支持HAL库<br>low layer ll 库<br>Hardware Abstraction Layer(HAL)</p>
<p>中间件，cubemx low layer</p>
<p>原理介绍：各种协议、各种器件原理<br>搭配CubeMX: 生成代码</p>
<p>DSP：数字信号处理<br>FPU：浮点运算单元</p>
<p>IAR CubeIDE keil</p>
<p>STM32介绍 ST: 意法半导体 M: 微电子 32总线宽度。 MCU微控制器（单片机）微型计算机系统<br>选型和开发介绍。<br>1、参考手册：一般描述这款芯片，软件上怎么使用。<br>2、数据手册：大致的介绍功能等。</p>
<p>引脚分配<br>电源IO<br>晶振IO<br>下载IO<br>BOOT IO<br>复位IO<br>GPIO</p>
<p>原理图绘制-&gt;PCB layout-&gt;程序编写。</p>
<p>寄存器编程</p>
<p>函数库编程</p>
<p>寄存器：外设的地址</p>
<p>FLASH、SRAM地址</p>
<p>GPIO内部结构框图</p>
<p>IDE: 为你设置好了堆栈</p>
<p>配置：<br>1、运行环境管理工具<br>2、从我们的库包中添加。</p>
<p>Dummy-Robot:<br>startup:<br>启动文件 xxxx.s</p>
<p>Drivers<br>    CMSIS<br>        Device: CMSIS 的相关东西</p>
<p>system_stm32f1xx.c f1 的启动文件？</p>
<p>通过总线的形式，可以很好将各种外设分离开，可以独立将各种外设来控制它的是能与否。控制外设是能与否就是控制这个外设的时钟。时钟频率越高，耗能越高。</p>
<p>仿真器：<br>JTAG接口<br>SWD接口</p>
<p>软件开发步骤：<br>1、使能GPIOB的外设时钟。外设基地址：0x40021000 APB2 外设时钟使能寄存器地址：偏移0x18</p>
<p>2、通过查阅参考手册的GPIO章节，知道了要配置推挽输出模式。通过端口配置表展示的寄存器来进行配置。<br>外设基地址+偏移。GPIOB 0x40010C00 偏移：CRL偏移：0x00 ODR偏移：0x0c</p>
<p>3、使用HAL库之后，就是用HAL库来初始化就好了吧。</p>
<p>2、根据需要配置的功能寻找参考手册</p>
<p>#define GPIOB_CLK (*(volatile unsigned int <em>)(0x40021000 + 0x18))<br>#define GPIOB_CRL (</em>(volatile unsigned int <em>)(0x40021000 + 0x18))<br>#define GPIOB_ODR (</em>(volatile unsigned int *)(0x40021000 + 0x18))</p>
<p>int main(void)<br>{<br>    &#x2F;&#x2F; 使能GPIO时钟<br>    GPIOB_CLK |&#x3D; (1&lt;&lt;3)</p>
<pre><code>// 配置推挽输出模式
GPIOB_CRL &amp;= ~(0xf&lt;&lt;(4*0))
GPIOB_CRL |= 2 &lt;&lt; 0

// 参考原理图进行相应的配置。
GPIO_ODR &amp;= ~()
GPIOB_ODR |= ()
</code></pre>
<p>}</p>
<p>寄存器编程-&gt;库编程</p>
<p>1、代码可读性差<br>2、二次开发难度大<br>3、每次写程序都要查手册，麻烦</p>
<p>STM32的外设寄存器组织形式：<br>基于 基地址+寄存器偏移。</p>
<p>GPIO &#x2F;&#x2F; GPIO初始化结构体。<br>HAL_GPIO_Init()</p>
<p>1、循环和判断<br>找到GPIO的偏移位置。</p>
<p>先读<br>先清空对应位<br>写回</p>
<p>HAL固件包中的内容：<br>1、Documentation<br>说明文档<br>2、Drivers<br>包含BSP\CMSIS\HAL_Driver<br>3、Middlewares中间件<br>4、project<br>官方提供的各种工程实例，包含外设如何使用，以及外设与中间件的耦合。非常又参考价值。<br>5、Utilities<br>通用的一些文件，不重要。</p>
<p>使用HAL库<br>1、自己移植, .c .h文件<br>2. 使用CubeMx配置</p>
<p>知识的运用与BSP介绍。</p>
<p>什么是板级支持包<br>BSP Board Support Package 是介于主板硬件和操作系统中驱动层程序之间的一层，<br>一般认为它属于操作系统一部分，主要是实现对操作系统的支持，为上层的驱动程序提供<br>访问硬件设备寄存器的函数包，使之能够更好的运行于硬件主板。</p>
<p>用户应用层</p>
<p>板级支持包: 对板上的资源功能给出实现，并且提供用户程序的接口。以LED等为例，用户应用程序不需要知道GPIO的硬件特点，他只需要知道调用这个函数就可以点亮LED等。<br>应用程序操作灯和按钮，hal程序操作io引脚，板级支持包接收应用程序操作，转化成引脚操作</p>
<p>底层驱动</p>
<p>LED灯的板级支持包：<br>初始化GPIO<br>点亮、熄灭 LED</p>
<p>KEY的板级支持包<br>初始化GPIO(配置为输入，读取GPIO)</p>
<p>判断按键是否初始化<br>读取GPIO的电平引脚状态。</p>
<p>板级支持包的构建：看起来实际上就是给上层应用提供一个API</p>
<p>STM32程序的启动流程。<br>程序的启动流程</p>
<p>芯片商店以后回触发复位异常。<br>并且回跳转到中断向量表特定偏移位置。获取里面的内容取指执行。</p>
<p>触发复位异常-&gt;中断向量表-&gt;用户程序。</p>
<ol>
<li>初始化堆栈指针</li>
<li>设置PC指针的值</li>
<li>设置中断向量表</li>
<li>设置系统时钟。</li>
<li>调用C库函数__main 初始化堆栈的工作，最终回跳转到用户程序。</li>
</ol>
<p>修改复位异常内的内容，就可以让处理器去执行我们指定的操作</p>
<p>STM32的RCC外设<br>    RCC-复位和时钟控制</p>
<p>STM32 RCC知识</p>
<p>STM32的复位功能<br>    系统复位<br>    电源复位<br>    后备域复位 保存用户配置的。</p>
<p>时钟频率高。功率高。<br>STM32的时钟<br>    时钟简单理解为 “心跳”。STM会根据程序给定他的时钟节拍来工作。<br>    STM32主时钟</p>
<p>STM32的时钟树设计</p>
<p>使用</p>
<p>对于STM32上的时钟，具体怎么配置，根据需求决定。<br>时钟频率越高，功耗也会更高。<br>另一方面要考虑芯片的工作条件，根据芯片运行的工作条件选取不同的频率。</p>
<p>F429：<br>外部时钟&#x2F;M（分频因子 ）</p>
<p>STM32的中断<br>中断是指计算机运行过程中，需要，，，，</p>
<p>中断优先级。<br>通过 嵌套向量中断控制器。 来实现优先级<br>nvic_enableirq<br>nvic_disableirq</p>
<p>EXTI扩展中断和事件控制器<br>EXTI工程示例讲解。<br>事件—&gt;中断 事件–&gt;事件</p>
<p>EXTI外设可以大致概括为两个功能：</p>
<ul>
<li>捕获外部输入等事件 </li>
<li>生成EXTI中断等中断请求</li>
</ul>
<p>事件产生中断，然后调用相关的函数。</p>
<p>外部触发，软件触发，生成中断，唤醒CPU</p>
<p>工程演示：<br>STM32CubeMX 生成代码。</p>
<p>How to Use this driver</p>
<p>HAL_EXTI_SetConfigLine()</p>
<p>中断-&gt;中断向量表-&gt;偏移：入口地址-&gt;中断服务函数。<br>最终跳转到对应的中断服务函数中寻找。<br>stm32f1xx_it.c 或者放在最后的服务函数。</p>
<p>通过EXTI线，捕获EXTI线事件，并且生成中断，在中断中反转LED灯的状态，并且清除EXTI中断标志(中断标志要清除。不然会进入死循环)</p>
<p>SysTick-系统定时器<br>内核的外设<br>外设的原理及功能介绍<br>Systick定时器特性。</p>
<p>属于COrtex-M内核中的一个外设。内嵌在NVIC中。</p>
<p>计数宽度：<br>24bit来存储数据，2^24</p>
<p>向下递减：<br>计数器的工作模式，</p>
<p>计数器的工作周期：<br>1&#x2F;CLKSource, 1&#x2F;72Mhz</p>
<p>当重装在数值寄存器的值减到0，可以产生一个中断。</p>
<p>SysTick系统定时器是属于Cortex-M内核的外设。内核外设。</p>
<p>功能：<br>用于操作系统，用于产生时基，维持</p>
<p>延时功能的配置。 HAL_Delay函数就是根据Systick使用的。</p>
<p>HAL库驱动框架简述</p>
<ul>
<li>外设初始化</li>
<li>外设使用</li>
</ul>
<ol>
<li>对外设的封装</li>
</ol>
<ul>
<li>对外设的封装 xx_HandleTypeDef(XX外设句柄结构体，xx表示任意外设名)<ul>
<li>instatnce xx_TypeDef类型， 存放基地址，例如GPIO的文件。</li>
<li>Init成员 xx_InitTypeDef类型</li>
<li>Hdma *成员(DMA_HandleTypeDef类型，可能一个句柄结构体中有多个)</li>
<li>其他资源 LOCK STATUS HAL_LockTypeDef 类型 HAL_xx_StateTypeDef类型</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>外设初始化使用方法</p>
<ul>
<li>HAL_xx_init, 参数一般为xx外设的句柄结构体</li>
<li>HAL_xx_MspInit，参数一般为xx外设的句柄结构体 将外设使用到的底层资源初始化完成 Init the low level hardware : GPIO, CLOCK, NVIC… 为一个弱定义，需要我们用户来自己实现。</li>
<li>其他Init方法：具体参考，HAL库，How to use this Driver</li>
</ul>
</li>
<li><p>外设使用逻辑</p>
<ul>
<li>阻塞轮询(Polling)<br>  xx_start<br>  xx_read、write<br>  等等函数</li>
<li>中断<br>  xx_start_it<br>  xx_read\write_it<br>  xx_xx_it 等等中断启动函数。特指，函数名以IT结尾。</li>
<li>DMA<br>  xx_start_dma – DMA功能<br>  xx_read\write_dma<br>  xx_xx_dma</li>
<li>其他功能 标志的查询\清楚 中断使能，失能。</li>
</ul>
</li>
<li><p>全面了解：How to User This Driver</p>
</li>
</ol>
<p>Debug功能及Debug方法简述</p>
<ul>
<li>硬件调试</li>
<li>打印调试</li>
<li>调试器调试</li>
</ul>
<p>通讯的基本概念：<br>全双工，半双工。串行 并行 等。</p>
<p>USART</p>
<p>UART主要用来产生相关接口的协议信号。UART广泛引用与串口通信中，扮演者传输器的角色。</p>
<p>RS-232标准介绍。</p>
<p>一般开发板上使用的点评标准与通讯使用的电平·标准不同。</p>
<p>UART外设的使用：</p>
<ol>
<li>定义一个UART_HandleTypeDef结构体句柄</li>
<li>通过HAL_UART_MspInit函数来实现要做的功能<ul>
<li>使能UART外设的时钟</li>
<li>配置UART使用的引脚模式</li>
<li>如使用中断，需要将中断配置好。</li>
<li>HAL_UART_INIT</li>
</ul>
</li>
</ol>
<p>DMA-直接存储器访问控制器</p>
<p>外设与存储器，存储器与存储器之间，提供高速数据传输。</p>
<p>DMA就是CPU的助手、数据搬运工。<br>DMA控制器的实现基于复杂的总线架构。</p>
<p>1、DMA请求<br>2、通道选择<br>3、FIFO功能<br>4、数据搬运的目标地址</p>
<p><strong>DMA的功能就是建立起一个数据传输通道。</strong></p>
<p>串口DMA，串口接收数据，放到内存中。</p>
<ol>
<li><p>建立传输通道<br> 存储器-&gt;存储器<br> 外设-&gt;存储器<br> 存储器-&gt;外设</p>
</li>
<li><p>确定传输对象<br> 具体的功能<br> UART-内存<br> 内存数据-UART</p>
</li>
<li><p>传输的细节<br> 确定由谁产生DMA请求。外设的DMA请求外设通道<br> 通道的优先级<br> 确定传输数据双方数据的格式<br> 确定数据是否需要一直采集（循环模式）</p>
</li>
</ol>
<p>单次传输<br>突发传输。</p>
<p>串口外设数据寄存器地址。不能地址。内存地址应该是要递增的。</p>
<p>HAL库中的DMA功能实例<br>HandleTypeDef instance</p>
<p>使用cubemx 进行初始化代码。<br>实际的代码逻辑。</p>
<p>串口外设模式下的演示。</p>
<p>EEPROM<br>I2C通信协议<br>广泛地使用在系统内多个继承电路间的通讯。<br>支持多设备的总线。<br>一个I2C总线两条总线。SDA SCL</p>
<p>每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址</p>
<p>多个主机同时使用总线时，为了防止数据冲突，会利用冲裁的方式。</p>
<p>I2C的协议层<br>通信的起始，终止信号。</p>
<p>I2C总线上的每个设备都有自己的独立地址。</p>
<p>相应。</p>
<p>如何使用STM32产生I2C协议信号。</p>
<p>软件模式协议：使用CPU直接控制通讯引脚的点评，产生出符合通讯协议标准的逻辑。</p>
<p>硬件实现协议：</p>
<p>STM32的I2C控制器特性介绍<br>I2C 读写EEPROM实验。</p>
<p>Fat文件系统的移植。<br>1、把FatFS的源码拷贝到工程文件夹目录</p>
<p>新建一个10x的工程，然后把axf拷贝过去，然后烧录，需要准备keil 安装包。<br>芯片包等。</p>
<p>SPI QSPI的通信内容<br>FLASH固件来实现</p>
<p>Serial Peripheral Interface</p>
<p>SPI的写入过程，手动查出，然后</p>
<ol>
<li>初始化通信使用的目标引脚和时钟。</li>
<li>使能spi外设的时钟。</li>
<li>配置spi外设的模式，速率，等</li>
<li>编写按字节收发的函数。<br>将片选信号拉低，<br>等待数据发送完成标志。<br>将数据写入spi数据寄存器中</li>
</ol>
<p>CAN 是控制完了过总西南。<br>CAN通信并不是以时钟信号来进行同步的，它是一种异步通信，CAN_High,CAN_Low两条信号线，<br>共同构成一组差分信号线，以差分信号的形式进行通信。</p>
<p>CAN物理层组要分为闭环和开环总线网络两种，一个适合于告诉通讯，一个适合于远距离通讯。<br>闭环速度快，传输距离段<br>开环</p>
<p>差分信号的有点，抗干扰，定位精确。</p>
<p>CAN的波特率及位同步<br>CAN时异步通信，没有时钟信号线。<br>CAN还会使用 “位同步”的方式来抗干扰、吸收误差，实现对总线电平</p>
<p>通讯的波特率</p>
<p>CAN使用两个差分信号线，只能表达一个信号，<br>复杂的协议来补充这一点。<br>报文。</p>
<p>差分信号。<br>数据帧。<br>数据帧<br>遥控帧<br>错误帧<br>过载帧<br>帧间隔</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/02/computer_science/csapp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://srcnn-blog.oss-cn-hangzhou.aliyuncs.com/2023-10-06-15-57-57_0d920927.png">
      <meta itemprop="name" content="srcnn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/02/computer_science/csapp/" class="post-title-link" itemprop="url">csapp</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-02 11:03:44" itemprop="dateCreated datePublished" datetime="2022-01-02T11:03:44+08:00">2022-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2022/01/02/computer_science/csapp/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2022/01/02/computer_science/csapp/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>instruction set architecture, or ISA<br>virtual address<br>the programe counter</p>
<p>virtual address and programe counter</p>
<p>register file contain 16 named locations storing 64-bit values.<br>These registers can hold addresses(corresponding to C pointer) &#x2F;&#x2F; 保存的是地址。！！！！不管什么，保存的都是地址。。。<br>The condition code registers hold status informatino about the most recently executed arithemetci or logical instruction. These are used to implement condition</p>
<p>A set of vector resiters can each hold one or more integer or floating-point values</p>
<p>Even for scalar data types, assembly code makes no distinctions between signed or unsigned integers, between different types of pointers, or even between pointers and integers.</p>
<p>A key lesson to learn from this is that the program executed by the machine is simply a sequence of bytes encoding a series of instructions.</p>
<p>16bits: word<br>32bits: double words<br>64bits: quad words</p>
<p>16 general-purpose register storing 64-bit values. These registers are used to store integer data as well as pointers.</p>
<p>operand specifiers<br>操作数 most instruction have one or more operands specifying the source values to use in performing an operation and the destinaton location into which to place the result.</p>
<p>This technique takes advantage of the property that an instruction generating a 4-byte value with a register as the destination will fill the upper 4 bytes with zeros.</p>
<p>mismatch between instruction suffix and register ID</p>
<p>By way of background, a stack is a data structure whre values can be added or deleted, but only according to a “last-in, first-out” discipline.</p>
<p>operations are divided into four groups: load effective address, unary, binary, and shifts</p>
<ul>
<li>lea</li>
<li>unary 一元</li>
<li>binary 二元</li>
<li>shifts 移位</li>
</ul>
<p>leaq: instead of reading from the designated location, the instruction copies the effective address to the destination.</p>
<p>Note that when the second operand is a memory location, the processor must read the value from memory, perform the operation, and then write the result back to memory</p>
<p>CF (unsigned) t &lt; (unsigned) a Unsigned overflow<br>ZF (t &#x3D;&#x3D; 0) Zero<br>SF (t &lt; 0) Negetive<br>OF (a &lt; 0 &#x3D;&#x3D; b &lt; 0) &amp;&amp; (t &lt; 0 !&#x3D; a &lt; 0) Signed overflow</p>
<p>use contion code<br>1、we can set a single byte to 0 or 1 depending on some combination of the condition codes<br>2、we can conditionally jump to some other part of the progrma<br>3、we can conditionally transfer data.</p>
<p>In generating the object-code file, the assembler determines the addresses of all labeled instructions and encodes the jump targets (the addresses of the destination instructions) as part of the jump instructions.</p>
<p>not that jump instruction, but the next instruction of jump</p>
<p>Implementing Conditional Branches with Conditional Moves</p>
<p>why code based on conditional data transfers can outperform code based on conditional control transfers?</p>
<p>processors achieve high performance though pipelining,  – branch prediction logic</p>
<p>such a misprediction can incur a serious penalty,say,15-30clock cycles of wasted effort, causing a serious degradation of program performance</p>
<p>combination of conditional tests and jumps are used to implement the effect of loops.</p>
<p>switch allow an efficient implementation using a data structure called a jump table.</p>
<p>use of a jump table allows a very efficient way to implement a multiway branch</p>
<p>procedure involve:</p>
<ol>
<li>Passing control</li>
<li>Passing data.</li>
<li>Allocating and deallocating memory</li>
</ol>
<p>3.7.4 接下来应该读 Local Storage on the Stack</p>
<p>static:link</p>
<ol>
<li>找到符号。f 定位每一个函数f，能够定位到全局变量</li>
<li>symbol resolution</li>
<li>relocate</li>
</ol>
<p>文件elf<br>读头，寻道<br>连续的0&#x2F;1串，起来就是</p>
<p>本质上就是视角上的不同。</p>
<ul>
<li><p>offset n<br>bytes</p>
</li>
<li><p>offset </p>
</li>
<li><p>offset 0</p>
</li>
</ul>
<ol>
<li>disk address 即 offset 0 但是无法读到大小？</li>
</ol>
<p>ELF : magic number</p>
<p>0-&gt; header -&gt; section header table</p>
<p>大家好，今天主要讨论静态链接。我将会从符号定位、符号解析、以及重定位三个方面来介绍静态链接。符号定位主要讨论的是Linux如何利用ELF文件格式来定位函数和全局变量。符号解析主要讨论多个可重定位文件链接到一起时如何解析符号，遇到多重定义符号怎么处理等内容。重定位，主要讨论多个可重定位文件链接成可执行程序时如何修正全局变量和函数调用的调用地址。OK，废话不多说。那我们就开始吧。</p>
<p>我们将会使用这个例子，贯穿整个静态链接的介绍。这个例子很简单，从csapp这本书摘抄出来的。首先有一个sum函数，计算一个数组的和。有一个全局的array数组，里面有1和2两个数据。一个main函数，调用sum函数，计算array数组的和。我们将这个文件进行预处理，编译，汇编最终生成了一个main.o的文件。在计算机中，一个文件其实就是字节序列，就是一些01串而已。那么如何从main.o这个01串中定位到array符号的呢？array中包含的数据到底是怎么存放在main.o这个文件中呢？</p>
<p>在Linux中像main.o这种目标文件是被组织成一种特殊的格式，叫做<br>Executabl 可执行<br>Linkable 可链接<br>Format 格式<br>简称ELF格式。<br>这张图就展现了一个elf文件格式的基本结构。<br>最开始的offset 0就是这个文件开始的地方。文件开始有一个elf header。之后还有一些.text 段.data 段等。最后还有一个Section header table，就叫做节头表吧。它是描述.text .data节的。这张图已经给了ELF文件大概的全景图，接下来会分别介绍其中的细节。首先介绍一个ELF Header。只有解析了elf header之后，才能根据其中的内容解析elf文件的其他部分。<br>(hexdump -C main.o 看一下整体的预览。)<br>对于ELF，首部的信息包括文件类型、机器类型等信息。在Linux读取ELF文件时，Linux将ELF Header从Byte翻译成内存中的数据结构：这个结构体就像这张PPT展示的一样。通常一个elf header中会存放这么些个东西，这个结构体是从&#x2F;usr&#x2F;bin&#x2F;elf.h摘抄出来的。<br>每个项目列出来讲一讲。<br>e_indent<br>e_type<br>e_machine<br>e_version<br>e_entry<br>e_phoff<br>e_shoff<br>e_flags<br>e_ehsize<br>e_phentsize<br>e_phnum<br>e_shentsize<br>e_shnum<br>e_shstrndx<br>我们需要重点关注的是e_shoff, e_ensize e_shentsize e_shnum 变量。<br>&#x2F;&#x2F; 应该需要吧elf.h 和hexdump之后的文件放上去。对照着讲。结合着讲。<br>起始位置的16个字节为magic number，在这之后偏移2+2+4+8+8&#x3D;24个字节之后，为e_shoff，是section header table 的偏移量。数值为0x280 &#x3D; 640，在这之后，对e_shoff偏移4字节是e_ehsize&#x3D;0x40 表示elf header 的长度，即64个字节。我们可以看到整个elf_header 是64个字节，算得非常准确。最后是e_shnum &#x3D; 0x0d &#x3D; 13个section，字符串表的索引是12.好了我们，已经人眼识别，将整个elf header解析出来，接下来，我们用一个readelf工具，直接将header解析出来。</p>
<p>使用readelf -h main.o就可以将main.o的elf header解析出来了。划线的地方是需要重点关注的地方。使用readelf工具我们就可以更清楚的看到，section header table的偏移量，elf文件头的大小，每一个section header table的entry 大小。一个有多少个section header table。</p>
<p>OK，根据目前我们解析得到的内容，可以画出一个elf文件现在大概这样的。首先，有64Bytes的ELF header。在header中，根据e_shoff可以找到SHT的位置。根据e_shentnum我们可以知道一个有多少个SHT有多少个表项。根据e_shentsize可以知道SHT每个表项的大小。至此，我们可以计算出整个elf文件的大小。<br>e_shoff + e_shentnum * e_shentsize &#x3D; 1472字节。</p>
<p>接下来把目光放到section header table中。这个结构体就是描述section header table的。<br>SHT描述了ELF中不同的节，包括数据节、代码节等。这些Section中的数据是由编译器生成的，按照section的组织写入到磁盘上的ELF文件中。SHT的每一项都可以被数据结构ELF64_Shdr所描述。<br>列出来，讲一讲。<br>其中包含，<br>sh_name 它是string table的index<br>sh_type: section type:<br>sh_flags: section flasg</p>
<p>&#x2F;&#x2F; 需要结合代码展示一个hexdump的结构。</p>
<p>接下来我们就和解析ELF Header一样来人眼解析一个这个结构体。和解析ELF Header一样，对于SHT的每一个表项，按照上一页提到的数据结构逐个Byte解析，我们就可以得到.text对ELF文件的偏移：.sh_offset &#x3D; 0x00000000040。回忆起我们先前得知ELF header的大小就是0x40，也即64Bytes，因此.text所处的位置正是Header之后。并且，它的大小为.sh_size - 0x0000000024</p>
<p>同样的，我们可以使用readelf作弊一下，可以将所有的section header table列出来。<br>值得一提的是，SHT中总存在[0]项目，它被视为未定义的符号所在Section，SHN_UNDEF，也就是0.</p>
<p>OK，现在elf header和section header table已经解析完毕了，大概可以画出这么一张图。<br>首先解析，elf_header, 我们得到section header table的位置，解析section header table之后我们可以得到各个section 在文件中的位置，以及它的大小。</p>
<p>解析来我们把目光放在.symbol section中。关于什么是符号的问题。<br>由模块m定义并能被其他模块引用的全局符号。<br>由其他模块定义并被模块m引用的全局符号。<br>只被模块m定义和引用的局部符号。</p>
<p>类似elf header 和 section header table。符号表也是由一个结构体来描述的。<br>st_name: 符号的名字，它是字符串表的索引。<br>st_info: 高四位是bind信息，低四位是type信息。<br>st_other: 保留信息<br>st_shndx: 该符号保存在某个section的index<br>st_value: 保存在某个section的offset<br>st_size: 符号的大小。</p>
<p>符号的绑定类型主要有：<br>STB_LOCAL<br>STB_GLOBAL<br>STB_WEAK</p>
<p>符号的type主要有：<br>NOTYPE<br>OBJECT<br>FUNC</p>
<p>同样的我们可以肉眼解析一个符号。例如，开头提到的array<br>st_name 是0x08，在字符串表偏移8个字节的位置，<br>bind是1： 为STB_GLOBAL<br>type是1：为STT_OBJECT<br>st_shndx: 是3 说明这个符号存储在.data节<br>st_value是0，说明array在.data节开始的位置。<br>st_size是0x08, 说明array符号大小为8个字节。</p>
<p>自此，我们可以知道array符号在elf文件位置的计算公式：<br>start：.data节在elf文件的偏移量+st_value<br>end: start+st_size<br>最终我们找到了array符号的存储位置。</p>
<p>同样的，也可以使用readelf工具作弊一下，使用readelf -s 命令就可以将符号表的信息列举出来。</p>
<p>首先解析，elf_header, 我们得到section header table的位置，解析section header table<br>我们可以得到.symtab的位置，解析.symtab就可以得到各个符号在文件中的存储位置。自此，终于可以成功定位符号了。因而我们解决了开头提到的符号定位问题。</p>
<p>接下来介绍符号解析问题。</p>
<p>如何design file？？？？ 疯狂搞链接，套娃。。。。之类的。很像MP4文件格式，<br>所有的文件格式都是按照树，按照图去组织的。</p>
<p>external intenal层</p>
<p>如何知道符号表在文件中的哪一个位置。</p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><ol>
<li><p>size limit</p>
</li>
<li><p>速度</p>
</li>
<li></li>
<li><p>memory wall</p>
</li>
<li><p>share: consistant 一致性问题 </p>
</li>
<li><p>vapa</p>
</li>
<li><p>cache</p>
</li>
</ol>
<p>core<br>    L1 cache<br>        data<br>        inst<br>    L2 cache<br>    L3 cache L3 所有核共享</p>
<p>cache 三元组<br>CT, CI, CO<br>cache tag, cache index, cache offset<br>40, 6, 6</p>
<h1 id="cache-1"><a href="#cache-1" class="headerlink" title="cache"></a>cache</h1><h1 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h1><ul>
<li>SRAM<br>  for cache</li>
<li>DRAM<br>  for main memory</li>
</ul>
<p>Due to bistatble natue, the circuit will return to statble disturbance is removed</p>
<p>Each transfer of data between CPU and memory is accomplished with a series of<br>steps called a bus transaction.</p>
<p>Locality 局部性 程序的局部性</p>
<p>programs with good locality run faseter than programs with poor locality</p>
<p>true sharing 问题的产生。<br>多进程编程的true share的问题</p>
<p>cache Coherence</p>
<p>m bits that form M &#x3D; 2^m<br>S &#x3D; 2^s cache sets<br>Each set consists of E cache lines<br>Each line consists of a data block of B &#x3D; 2^b</p>
<p>Address<br>| t bits | s bits | b bits |<br>| tag    | set    | block  |<br>hit or miss the requested word </p>
<ol>
<li>set selection</li>
<li>line matching</li>
<li>workd extraction</li>
</ol>
<p>&#x2F;&#x2F; 缓存冲突。</p>
<h2 id="conflit-miss"><a href="#conflit-miss" class="headerlink" title="conflit miss"></a>conflit miss</h2><p>thrashing </p>
<p>APIC<br>advanced programable interrupt controller</p>
<ol>
<li>extend interrupt</li>
<li>trap&#x2F;system call 执行完指向下一个指令</li>
<li>Fault 执行完重新执行当前命令。</li>
<li>abort 直接挂掉。</li>
</ol>
<p>context switch 在内核中进行<br>trap：定时器，记录， trap syscall</p>
<p>exception handler<br>syscall handler</p>
<h2 id="ssespeflagscseip"><a href="#ssespeflagscseip" class="headerlink" title="ssespeflagscseip"></a>ss<br>esp<br>eflags<br>cs<br>eip</h2><p>error code</p>
<p>以上为Trap Frame</p>
<p>保存用户的一些寄存器。<br>user register 保存</p>
<p>load the segment selector for the new code segment and the new instruction pointer</p>
<h1 id="Exception-Control-Flow"><a href="#Exception-Control-Flow" class="headerlink" title="Exception Control Flow"></a>Exception Control Flow</h1><ul>
<li>exception</li>
<li>system call</li>
<li>singnal</li>
<li>nolocal jump</li>
</ul>
<p>exception finish happened things:</p>
<ul>
<li>goto I_curr</li>
<li>goto I_next</li>
<li>abort</li>
</ul>
<p>exception device to four class</p>
<ol>
<li>interrupts   async</li>
<li>traps sync</li>
<li>faults sync If the handler is able to correct the error condition, it returns control to the faulting instruction, thereby re-executing it. </li>
<li>aborts sync</li>
</ol>
<p>system call has a jump table in linux kernel</p>
<p>进程提供每个程序私有地址空间。</p>
<p>context switch:<br>(1) saves the context of the current process,<br>(2) restores the saved context of some previously preempted process, and<br>(3) passes control to this newly restored process.</p>
<p>fork COW 机制。<br>是否需要</p>
<p>fork 的COW机制。</p>
<p>control flow isolate</p>
<p>memory physical isolate</p>
<p>virtualization CPU virtualization memory</p>
<p>when the kernel switched a process p from kernel mode to<br>user mode, it checks the set of unblocked pending sinals</p>
<p>writing a correct Signal handlers<br>handler run concurrently with the main program ahd share the same global cariables, and thus can interfere with the main program and wich other handlers.</p>
<p>Because the pending bit vector contains exactly one bit for each type of signal,<br>there can be at most one pending signal of any particular type. </p>
<p>at least one signal has arrived<br>信号并不能排队处理，<br>signals cannot be used to count the occurrence of events in other processes</p>
<p>System calls can be interrupted.<br>programmers must include code the manually restart<br>interrupted system calls</p>
<p>Figure 8.40 shows one way to eliminate the race in Figure. By<br>blocking SIGCHILD signals before the call to fork and then unblocking.</p>
<p>在执行前先屏蔽子进程信号等操作。</p>
<p>setjump call<br>saves the current calling environment in the env buffer, for later use by longjmp, and return().</p>
<p>longjump may be cause memory leak</p>
<p>setlongjump并不是信号安全函数。需要小心谨慎的在回调函数使用信号安全函数。</p>
<p>将要会用户态的时候会去检查signal</p>
<p>do_signal: kernel mode</p>
<p>signal handler: user mode</p>
<p>usr trap in kernel</p>
<p>&#x2F;&#x2F; trapfrme_t<br>&#x2F;&#x2F; interrupt on kernel stack<br>&#x2F;&#x2F; save user frame 保护用户态的内核frame</p>
<p>&#x2F;&#x2F; push user frame context</p>
<p>&#x2F;&#x2F; recover user frame context</p>
<p>&#x2F;&#x2F; 维护内核的kernel stack rsp<br>&#x2F;&#x2F; 完成syscall, 完成内核之后就是安全的。</p>
<p>&#x2F;&#x2F; 为什么需要引入外部中断呢？</p>
<p>&#x2F;&#x2F; wait for system calls</p>
<p>&#x2F;&#x2F; time, the creation of god</p>
<p>static uint64_t global_time &#x3D; 0;<br>&#x2F;&#x2F; every time run a isa time plus one</p>
<p>&#x2F;&#x2F; 1. syscall: trap<br>&#x2F;&#x2F; 2. timer async extend tirggerd<br>&#x2F;&#x2F; 3. page fault. sync</p>
<p>&#x2F;&#x2F; 进程上下文切换。<br>&#x2F;&#x2F; context switch</p>
<p>&#x2F;&#x2F; context switch</p>
<p>&#x2F;&#x2F; page table</p>
<p>&#x2F;&#x2F;1. no page fault<br>va2pa normal func call once return once</p>
<p>&#x2F;&#x2F; 2. page fault<br>va2pa call once never return.</p>
<p>&#x2F;&#x2F; 1. 时间器的中断。<br>timer handler 无影响</p>
<p>&#x2F;&#x2F; 2. system call<br>syscall 这个也没有影响</p>
<p>&#x2F;&#x2F; 3. page fault<br>不适用nolocaljump不能解决这个问题。<br>发生pagefault，需要在执行一遍。</p>
<p>Descriptor table.<br>File table<br>v-node table</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/20/computer_science/platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://srcnn-blog.oss-cn-hangzhou.aliyuncs.com/2023-10-06-15-57-57_0d920927.png">
      <meta itemprop="name" content="srcnn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/20/computer_science/platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" class="post-title-link" itemprop="url">platform设备驱动</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-20 22:39:00" itemprop="dateCreated datePublished" datetime="2021-10-20T22:39:00+08:00">2021-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2021/10/20/computer_science/platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2021/10/20/computer_science/platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="设备驱动模型"><a href="#设备驱动模型" class="headerlink" title="设备驱动模型"></a>设备驱动模型</h1><p>对于 Linux 这样一个成熟、庞大、复杂的操作系统，代码的重用性非常重要，否则的话就会在Linux内核中存在大量无意义的重复代码。当前Linux使用设备(device)，总线(bus)，驱动(driver)模型。Linux设备驱动模型如下图所示。</p>
<img src="/images/platform_driver.png" class="[Linux驱动模型示意图]" title="[14] [6] " alt="title text">
<p>设备和驱动各司其职，设备干设备的活，驱动干驱动的活，总线将两者匹配起来。一个Linux设备和驱动都需要挂接在一种总线上，对于USB、I2C、SPI等有物理总线直接的设备来说，没有任何问题，但是在SoC中有些外设是没有总线这个概念的，但是又要使用总线、驱动和设备模型该怎么办呢？因此，Linux发明了一种虚拟总线，称为platform总线。相应的设备称为platform_device，而驱动称为platform_driver。</p>
<h1 id="platform-driver"><a href="#platform-driver" class="headerlink" title="platform_driver"></a>platform_driver</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*probe)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">    <span class="type">int</span> (*remove)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">    <span class="type">int</span> (*suspend)(<span class="keyword">struct</span> platform_device *, <span class="type">pm_message_t</span> state);</span><br><span class="line">    <span class="type">int</span> (*resume)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line">    <span class="type">bool</span> prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>platform driver 结构体包含了probe remove。这个结构体用于注册驱动到platform总线。</p>
<h1 id="platform-device"><a href="#platform-device" class="headerlink" title="platform_device"></a>platform_device</h1><p>platform device的结构体如下所示。platform device结构体用于描述硬件信息，通常有一个名称用于和驱动绑定，还有一个资源列表，比如内存和中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>    *name;</span><br><span class="line">    <span class="type">int</span>        id;</span><br><span class="line">    <span class="type">bool</span>        id_auto;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>    <span class="title">dev</span>;</span></span><br><span class="line">    u64        platform_dma_mask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_dma_parameters</span> <span class="title">dma_parms</span>;</span></span><br><span class="line">    u32        num_resources;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span>    *<span class="title">resource</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span>    *<span class="title">id_entry</span>;</span></span><br><span class="line">    <span class="type">char</span> *driver_override; <span class="comment">/* Driver name to force a match */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MFD cell pointer */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* arch specific additions */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span>    <span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>platform设备的资源由resource结构体描述。flags可以是IORESOURCE_MEM、IORESOURCE_IRQ类型。当flags是IORESOURCE_MEM时，start、end表示该platform_device占据的内存的起始地址和结束地址；当flags是IORESOURCE_IRQ时，表示该platform_device使用的中断号的开始值和结束值，如果使用了1个中断号，开始和结束值相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">    <span class="type">resource_size_t</span> start;  <span class="comment">// 表示资源的起始值，           </span></span><br><span class="line">    <span class="type">resource_size_t</span> end;    <span class="comment">// 表示资源的最后一个字节的地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">//资源的类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="platform-bus-type"><a href="#platform-bus-type" class="headerlink" title="platform bus type"></a>platform bus type</h1><p>系统为platform总线定义了一个bus_type的实例platform_bus_type。需要重点关注<code>platform_match</code>函数，该函数就是驱动和设备的匹配函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">platform_bus_type</span> =</span> &#123;</span><br><span class="line">    .name        = <span class="string">&quot;platform&quot;</span>,</span><br><span class="line">    .dev_groups    = platform_dev_groups,</span><br><span class="line">    .match        = platform_match,</span><br><span class="line">    .uevent        = platform_uevent,</span><br><span class="line">    .dma_configure    = platform_dma_configure,</span><br><span class="line">    .pm        = &amp;platform_dev_pm_ops,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">platform_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> =</span> to_platform_device(dev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">pdrv</span> =</span> to_platform_driver(drv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When driver_override is set, only bind to the matching driver */</span></span><br><span class="line">    <span class="keyword">if</span> (pdev-&gt;driver_override)</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attempt an OF style match first */</span></span><br><span class="line">    <span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then try ACPI style match */</span></span><br><span class="line">    <span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then try to match against the id table */</span></span><br><span class="line">    <span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line">        <span class="keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fall-back to driver name match */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出platform_match有四种匹配模式。一种是基于设备树风格的匹配；二是基于ACPI风格的匹配；三是ID表的匹配，platform_driver有一个id_table的变量；四是匹配platform_device设备名和驱动名。</p>
<h1 id="注册platform驱动"><a href="#注册platform驱动" class="headerlink" title="注册platform驱动"></a>注册platform驱动</h1><h2 id="注册设备"><a href="#注册设备" class="headerlink" title="注册设备"></a>注册设备</h2><p>platform_device_register函数可以注册设备.</p>
<h2 id="注册驱动"><a href="#注册驱动" class="headerlink" title="注册驱动"></a>注册驱动</h2><p>platform_driver_register函数可以注册驱动。</p>
<h1 id="match和probe函数的调用时机"><a href="#match和probe函数的调用时机" class="headerlink" title="match和probe函数的调用时机"></a>match和probe函数的调用时机</h1><p>下面的函数调用链展示了，设备和驱动何时通过match函数绑定到一起，以及何时执行驱动的probe函数。在调用<code>platform_driver_register</code>注册驱动时，会调用总线上的match函数，即platform_bus_type.match函数将驱动和设备绑定到一起，驱动和设备绑定成功之后，就会执行驱动的probe函数。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">platform_driver_register</span><br><span class="line">    __platform_driver_register</span><br><span class="line">        driver_register <span class="regexp">//</span> 注册驱动</span><br><span class="line">            bus_add_driver <span class="regexp">//</span> 将驱动添加到总线上</span><br><span class="line">                driver_attach <span class="regexp">//</span> 将驱动和设备绑定到一起</span><br><span class="line">                    __driver_attach</span><br><span class="line">                        driver_match_device</span><br><span class="line">                            drv-&gt;bus-&gt;match <span class="regexp">//</span> 最后调用总线上的match函数，即platform_bus_type.match函数，如上所述，共有四种match方式</span><br><span class="line"></span><br><span class="line">                        device_driver_attach <span class="regexp">//</span> 将特定的驱动和设备关联到一起</span><br><span class="line">                            driver_probe_device <span class="regexp">//</span> 驱动检测到设备后调用probe函数。</span><br><span class="line">                                really_probe</span><br><span class="line">                                    drv-&gt;probe <span class="regexp">//</span> 调用驱动的probe函数</span><br></pre></td></tr></table></figure>

<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>driver.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>    <span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>    <span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>        <span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_AUTHOR <span class="string">&quot;Jiang Zijin&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_DESC   <span class="string">&quot;A platform driver test&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pfd_driver_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;platform driver probe\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pfd_driver_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;platform driver remove\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">pfd_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name    = <span class="string">&quot;pfd_driver_test&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe        = pfd_driver_probe,</span><br><span class="line">    .remove        = pfd_driver_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* module_driver(__platform_driver, platform_driver_register, \</span></span><br><span class="line"><span class="comment">            platform_driver_unregister) */</span></span><br><span class="line"><span class="comment">/* 调用platform_driver_register注册驱动 */</span></span><br><span class="line">module_platform_driver(pfd_driver);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(DRIVER_AUTHOR);</span><br><span class="line">MODULE_DESCRIPTION(DRIVER_DESC);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>    <span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>    <span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>        <span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_AUTHOR <span class="string">&quot;Jiang Zijin&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">test_pfd_release</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">test_pdev</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">    .name = <span class="string">&quot;pfd_driver_test&quot;</span>,</span><br><span class="line">    .id = <span class="number">-1</span>,</span><br><span class="line">    .dev.release = test_pfd_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">test_pdev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;platform device init\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> platform_device_register(&amp;test_pdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">test_pdev_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;platform device exit\n&quot;</span>);</span><br><span class="line">    platform_device_unregister(&amp;test_pdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(test_pdev_init);</span><br><span class="line">module_exit(test_pdev_exit)</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(DRIVER_AUTHOR);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">KVERS = $(shell uname -r)</span><br><span class="line"></span><br><span class="line"># Kernel modules</span><br><span class="line">obj-m += pfd_driver.o pfd_device.o</span><br><span class="line"></span><br><span class="line"># Specify flags <span class="keyword">for</span> the module compilation.</span><br><span class="line">EXTRA_CFLAGS=-g -O0</span><br><span class="line"></span><br><span class="line">build: kernel_modules</span><br><span class="line"></span><br><span class="line">kernel_modules:</span><br><span class="line">	make -C /lib/modules/$(KVERS)/build M=$(CURDIR) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	make -C /lib/modules/$(KVERS)/build M=$(CURDIR) clean</span><br></pre></td></tr></table></figure>

<p>执行make即可成功编译出<code>pfd_driver.ko</code>和<code>pfd_device.ko</code>两个内核文件。可使用insmode加载这两个内核文件。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insmod pfd_device<span class="selector-class">.ko</span></span><br><span class="line">insmod pfd_driver<span class="selector-class">.ko</span></span><br><span class="line"><span class="selector-attr">[  556.856482]</span> platform device init</span><br><span class="line"><span class="selector-attr">[  561.823973]</span> platform driver probe</span><br></pre></td></tr></table></figure>
<p>加载后使用<code>demsg</code>打印内核信息即可看到<code>platform device init</code>和<code>platform driver probe</code>的打印。这说明platform设备和驱动绑定到一起了，绑定成功之后就执行驱动的probe函数。</p>
<p>ok，这个例子似乎有点简单，加点资源进去。加上一点内存和中断号的资源，并在驱动的probe函数中使用。在驱动中很容易就可以使用到这些资源了。</p>
<p>TODO： 把相应代码加上。</p>
<p>[  432.948791] platform device init<br>[  437.752513] platform driver probe<br>[  437.752517] mem start addr &#x3D; 12340000<br>[  437.752520] irq num &#x3D; 100</p>
<h1 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h1><p>从上面的例子可以发现，platform device可能除了一些resource资源不一样外，其他部分大差不差的。如果每来一个设备都需要写一个xxx_device.c，那么内核代码就会很臃肿。因此引入了描述硬件的数据结构–设备树。采用设备树之后，许多硬件的细节可以直接通过它传递给Linux，而不再需要在内核中进行大量的冗余编码。</p>
<p>本文不对设备树进行过多介绍，仅展示使用设备树之后的便利性。<br>上述的例子中，我们可以把device相关的代码改用dts实现，只需要在dts中正确配置即可，无需在写那么多的设备代码了。在设备和驱动match过程中，通过相应的dts的接口match上。</p>
<h1 id="dts方式的match"><a href="#dts方式的match" class="headerlink" title="dts方式的match"></a>dts方式的match</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">of_driver_match_device <span class="regexp">//</span> 驱动的of_match_table是否match上了相应的设备</span><br><span class="line">    of_match_device</span><br><span class="line">        of_match_node</span><br><span class="line">            __of_match_node</span><br><span class="line">                __of_device_is_compatible</span><br><span class="line">                    __of_find_property <span class="regexp">//</span> prop = __of_find_property(device, <span class="string">&quot;compatible&quot;</span>, NULL); 最终是利用dts的<span class="string">&quot;compatible&quot;</span>来匹配的，即设备树加载之后，内核会自动把设备树节点转换成platform_device这种格式，同时把名字放到of_node这个地方。</span><br></pre></td></tr></table></figure>

<h1 id="改写example"><a href="#改写example" class="headerlink" title="改写example"></a>改写example</h1><p>设备树的详细内容这里就不再展开介绍了，下面将上述例子的device部分改写成设备树实现，展示一下使用设备树的便利性。<br>TODO: 把代码贴上去。直接该内核的。 已完成，放到公司内网中了。<br>参考：<br>《Linux设备驱动开发详解》<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/134180200">https://zhuanlan.zhihu.com/p/134180200</a><br><a target="_blank" rel="noopener" href="https://biscuitos.github.io/blog/DTS/#:~:text=DTS%20%E6%98%AF%E4%B8%BA%20Linux%20%E6%8F%90%E4%BE%9B%E4%B8%80%E7%A7%8D%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BB%A5%E6%AD%A4%E4%BB%A3%E6%9B%BF%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%20%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A0%81%20%28hard%20code%29%E3%80%82%20DTS,%28OF%29.%20%E5%9C%A8%20Linux%202.6%20%E4%B8%AD%EF%BC%8C%20ARM%20%E6%9E%B6%E6%9E%84%E7%9A%84%E6%9D%BF%E7%BA%A7%E7%A1%AC%E4%BB%B6%E7%BB%86%E8%8A%82%E8%BF%87%E5%A4%9A%E7%9A%84%E8%A2%AB%E7%A1%AC%E7%BC%96%E7%A0%81%E5%9C%A8%20arch%2Farm%2Fplat-xxx">https://biscuitos.github.io/blog/DTS/#:~:text=DTS%20%E6%98%AF%E4%B8%BA%20Linux%20%E6%8F%90%E4%BE%9B%E4%B8%80%E7%A7%8D%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BB%A5%E6%AD%A4%E4%BB%A3%E6%9B%BF%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%20%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A0%81%20%28hard%20code%29%E3%80%82%20DTS,%28OF%29.%20%E5%9C%A8%20Linux%202.6%20%E4%B8%AD%EF%BC%8C%20ARM%20%E6%9E%B6%E6%9E%84%E7%9A%84%E6%9D%BF%E7%BA%A7%E7%A1%AC%E4%BB%B6%E7%BB%86%E8%8A%82%E8%BF%87%E5%A4%9A%E7%9A%84%E8%A2%AB%E7%A1%AC%E7%BC%96%E7%A0%81%E5%9C%A8%20arch%2Farm%2Fplat-xxx</a></p>
<p>platform驱动转成dts<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zqixiao_09/article/details/50889458">https://blog.csdn.net/zqixiao_09/article/details/50889458</a></p>
<p>source code:<br><a target="_blank" rel="noopener" href="https://gitee.com/jzijin/linux_driver">https://gitee.com/jzijin/linux_driver</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/01/life/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://srcnn-blog.oss-cn-hangzhou.aliyuncs.com/2023-10-06-15-57-57_0d920927.png">
      <meta itemprop="name" content="srcnn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/01/life/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/" class="post-title-link" itemprop="url">高效能人士的七个习惯</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-01 23:04:17" itemprop="dateCreated datePublished" datetime="2021-09-01T23:04:17+08:00">2021-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/humanities/" itemprop="url" rel="index"><span itemprop="name">humanities</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2021/09/01/life/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2021/09/01/life/%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>近期陷入迷茫中，不知道工作有什么意思，生活总是很无聊。总是在思考终极的哲学问题，我想我不能在这样下去了，这样下去不得疯了？因此，来寻找毒鸡汤了，又拿出了很久之前读过的《高效能人士的七个习惯》来重新翻阅寻找一下力量了。</p>
<!---more--->

<h1 id="chapter-1-由内而外全面造就自己"><a href="#chapter-1-由内而外全面造就自己" class="headerlink" title="chapter 1 由内而外全面造就自己"></a>chapter 1 由内而外全面造就自己</h1><blockquote><p>没有正确的生活，就没有真正卓越的人生。</p>
<footer><strong>David Starr Jordan</strong></footer></blockquote>

<p>要改变现状，首先要改变自己；要改变自己，先要改变我们对问题的看法。</p>
<h2 id="品德与个人魅力孰重"><a href="#品德与个人魅力孰重" class="headerlink" title="品德与个人魅力孰重"></a>品德与个人魅力孰重</h2><p>不要总是用”术”，更多的真诚待人。</p>
<h2 id="光有技巧还不够"><a href="#光有技巧还不够" class="headerlink" title="光有技巧还不够"></a>光有技巧还不够</h2><p>技巧不是最重要的，不要老是用技巧。过多使用技巧有时会适得其反，真诚待人才是王道。只有品德才是交流中最伶俐的“口齿”，正如美国诗人爱默生所说：“大声喧哗反而难以入耳”。人性可善可恶，冥冥中影响着我们的一生，而且总是如实反映出真正的自我，那是伪装不来的。</p>
<h2 id="思维方式的力量"><a href="#思维方式的力量" class="headerlink" title="思维方式的力量"></a>思维方式的力量</h2><p>我们总是用思维方式绘制的地图诠释所有的经验，从来都不怀疑地图的正确性，甚至意识不到它们的存在。我们理所当然地假定自己的所见所闻就是真是的世界。<br>我们总以为只有自己清楚而客观地看到了事物的本质，但这个实验却让我们开始认识到，别人的观点虽然又差异，但也是清楚而客观的。“立场决定观点。”</p>
<h2 id="思维转换力量"><a href="#思维转换力量" class="headerlink" title="思维转换力量"></a>思维转换力量</h2><p>“一棵邪恶的大树，砍它枝叶千斧，不如砍它根基一斧。”行为和态度就是枝叶，思维方式就是根基，抓住根本才能让生活出现实质性的进展。</p>
<h2 id="身体力行"><a href="#身体力行" class="headerlink" title="身体力行"></a>身体力行</h2><p>思维转换的力量也正是定式改变必需的力量，无论这种转变是立即发生的，还是经过计划缓慢进行的。</p>
<h2 id="已原则为中心的思维方式"><a href="#已原则为中心的思维方式" class="headerlink" title="已原则为中心的思维方式"></a>已原则为中心的思维方式</h2><p>现代人的精神危机：<br>我真正缺少的东西就是要在我内心弄清楚：我到底要做什么事情？问题在于，要找到一个对我来说确实的真理，找到一个我能够为此而生、为此而死的新年。</p>
<p>一个人能承受多少真相，是对他的精神强度的考验。</p>
<h2 id="成长和改变的原则"><a href="#成长和改变的原则" class="headerlink" title="成长和改变的原则"></a>成长和改变的原则</h2><p>如果学生不肯发问，不肯暴露自己的无知，不肯让老师知道他的真正水平，那么绝对学不到东西，也就不可能有长进。梭罗曾今说过：“如果我们时时忙着展现自己的知识，将何从忆起成长所需的无知？”</p>
<p>只有真正经历过拥有，才会真正懂得分享。</p>
<h2 id="症状在于治标不治本"><a href="#症状在于治标不治本" class="headerlink" title="症状在于治标不治本"></a>症状在于治标不治本</h2><h2 id="新的思想水平"><a href="#新的思想水平" class="headerlink" title="新的思想水平"></a>新的思想水平</h2><p>以原则为中心，以品德为基础，要求“由内而外”地实现个人效能和人际效能。<br>由内而外的观点认为个人领域的呈贡必须先于公众领域的成功；只有先信守对自己的承诺，才能信守对他人的承诺。<br>我们必不可停止探索，而一切探索的尽头，就是重回起点，并对起点有如初见般的了解。</p>
<h1 id="七个习惯概论"><a href="#七个习惯概论" class="headerlink" title="七个习惯概论"></a>七个习惯概论</h1><blockquote><p>人的行为总是一再重复。因此卓越不是一时的行为，而是习惯。</p>
<footer><strong>亚里士多德</strong></footer></blockquote>

<h2 id="“习惯”的定义"><a href="#“习惯”的定义" class="headerlink" title="“习惯”的定义"></a>“习惯”的定义</h2><p>习惯定义为“知识”、“技巧”、与“意愿”相互交织的结果。<br>改变习惯是一个痛苦的过程，因为有了更高的目标才能激发改变，面向未来牺牲当下的意愿才能促进改变。但是这又是幸福的源泉，是生活的目标和规划。从这个角度来说，幸福就是我们经过一番努力与牺牲得到的果实。</p>
<h2 id="成熟模式图"><a href="#成熟模式图" class="headerlink" title="成熟模式图"></a>成熟模式图</h2><ul>
<li>依赖期 以“你”为核心 – 你照顾我；你为我的得失成败负责</li>
<li>独立期 以“我”为核心 – 我可以做到；我可以负责；我可以靠自己；我有权选择。</li>
<li>互赖期 以“我们”为核心 – 我们可以做到；我们可以合作；我们可以融合彼此的智慧和能力，共创前程。</li>
</ul>
<h2 id="“效能”的定义"><a href="#“效能”的定义" class="headerlink" title="“效能”的定义"></a>“效能”的定义</h2><p>“产出&#x2F;产能”平衡。伊索寓言中的鹅生金蛋的故事。效能在于产出和产能的平衡。P代表希望获得的产出，即金蛋；PC代表产能，即生产金蛋的资产或能力。</p>
<h2 id="三类资产"><a href="#三类资产" class="headerlink" title="三类资产"></a>三类资产</h2><ul>
<li>物质资产</li>
<li>金融资本</li>
<li>人力资本</li>
</ul>
<p>急功近利常常会毁掉宝贵的物质资产。保持产出与产能的平衡会帮助你更有效地利用物质资产。写程序应该也是这样吧。慢就是快，欲速则不达，read deeply！！</p>
<p>我们最宝贵的金融资本就是赚钱的能力。如果不能持续投资以增进自己的产能，眼光就会受到限制，只能在现有的职位上踏步，每天忙忙碌碌。</p>
<h2 id="你将获得什么？"><a href="#你将获得什么？" class="headerlink" title="你将获得什么？"></a>你将获得什么？</h2><p>对自己的改变要有耐心，因为自我成长是神圣的，同时也是脆弱的，是人生中最大的投资。虽然这需要长时间下功夫，但是必定会有鼓舞人心的可喜成效。</p>
<p>得之太易者必不受珍惜。唯有付出代价，万物始有价值。上苍深知如何为其产品制订合理的价格。</p>
<h2 id="七个习惯的简要定义"><a href="#七个习惯的简要定义" class="headerlink" title="七个习惯的简要定义"></a>七个习惯的简要定义</h2><ol>
<li>积极主动</li>
<li>以终为始</li>
<li>要事第一</li>
<li>双赢思维</li>
<li>知彼解己</li>
<li>统合综效</li>
<li>不断更新</li>
</ol>
<h1 id="chapter-2-习惯一-积极主动-–-个人愿景原则"><a href="#chapter-2-习惯一-积极主动-–-个人愿景原则" class="headerlink" title="chapter 2 习惯一 积极主动 – 个人愿景原则"></a>chapter 2 习惯一 积极主动 – 个人愿景原则</h1><p>人性的本质是主动而非被动的，人类不仅能针对特定环境选择回应方式，更能主动创造有利的环境。采取主动不等于胆大妄为、惹是生非或滋事挑衅，而是要充分认识到自己有责任创造条件。</p>
<h2 id="社会之镜"><a href="#社会之镜" class="headerlink" title="社会之镜"></a>社会之镜</h2><p>解释人性的三种决定论</p>
<ul>
<li>基因决定论</li>
<li>心理决定论</li>
<li>环境决定论</li>
</ul>
<h2 id="刺激和回应之间选择的自由"><a href="#刺激和回应之间选择的自由" class="headerlink" title="刺激和回应之间选择的自由"></a>刺激和回应之间选择的自由</h2><p>人性最根本的原则，即在刺激与回应之间，人有选择的自由。选择的自由包括人类特有的四种天赋。自我意识，想象力，良知，独立意志。</p>
<h2 id="“积极主动”的定义"><a href="#“积极主动”的定义" class="headerlink" title="“积极主动”的定义"></a>“积极主动”的定义</h2><p>积极主动不仅指行事的态度，还意味着人一定要对自己的人生负责。个人行为取决于自身的抉择，而不是外在的环境，人类应该有营造有利的外在环境的积极性和责任感。<br>伤害我们的并非悲惨遭遇本身，而是我们对于悲惨遭遇的回应。</p>
<h2 id="采取主动"><a href="#采取主动" class="headerlink" title="采取主动"></a>采取主动</h2><h2 id="变被动为主动"><a href="#变被动为主动" class="headerlink" title="变被动为主动"></a>变被动为主动</h2><p>积极行动不同于积极思考。我们不但需要面对现实，还要面对未来。但真正的现实是，我们有能力以积极态度应对现状和未来，逃避这一现实，就只能被动地让环境和条件决定一切。</p>
<h2 id="聆听自己的声音"><a href="#聆听自己的声音" class="headerlink" title="聆听自己的声音"></a>聆听自己的声音</h2><p>在所有进步的社会中，爱都是代表动作，但消极被动的人却把爱当作一种感觉。</p>
<h2 id="关注圈和影响圈"><a href="#关注圈和影响圈" class="headerlink" title="关注圈和影响圈"></a>关注圈和影响圈</h2><p>每个人都有格外关注的问题，比如健康，子女，事业，工作，股票等。这些被归入 关注圈 中，以区别与自己没有兴趣或不愿理会的事物。</p>
<p>关注圈内的事物，有些可以被掌控，有些则超出个人能力范围，前者可以被形成一个较小的“影响圈”<br>消极被动的人全神贯注于“关注圈”，而积极主动的人虽然更看重自己的影响力，但他们的关注圈往往不小于影响圈子。</p>
<h2 id="直接控制、间接控制和无法控制"><a href="#直接控制、间接控制和无法控制" class="headerlink" title="直接控制、间接控制和无法控制"></a>直接控制、间接控制和无法控制</h2><ul>
<li>可直接控制问题：可以通过培养正确习惯来解决，这显然在影响圈范围内。</li>
<li>可间接控制的问题：可以通过改进施加影响的方法来解决，例如采取移情方式而不是针锋相对，以身作则而不是口头游说。</li>
<li>无法控制的问题：我们要做的就是改变面部曲线，以微笑、真诚与平和来接收现实。</li>
</ul>
<h2 id="扩大影响圈"><a href="#扩大影响圈" class="headerlink" title="扩大影响圈"></a>扩大影响圈</h2><p>有人误以为“积极主动”就是胆大妄为、滋事挑衅或目中无人，其实不然，及积极处世者只是更为机敏，更重视价值观，能够切乎实际，并掌握问题的症结所在。</p>
<h2 id="“如果”和“我可以”"><a href="#“如果”和“我可以”" class="headerlink" title="“如果”和“我可以”"></a>“如果”和“我可以”</h2><h2 id="硬币的另一面–应对错误的选择"><a href="#硬币的另一面–应对错误的选择" class="headerlink" title="硬币的另一面–应对错误的选择"></a>硬币的另一面–应对错误的选择</h2><p>对于已经无法挽回的错误，积极主动的人不是悔恨不已，而是承认往日错误已属关注圈的事实，那是人力无法企及的范畴，既不能从头来过，也不能改变必然后果。</p>
<h2 id="做出承诺，信守诺言"><a href="#做出承诺，信守诺言" class="headerlink" title="做出承诺，信守诺言"></a>做出承诺，信守诺言</h2><p>影响圈的核心就是做出承诺与信守诺言的能力。积极主动的本质和最清晰的表现就是对自己或别人有所承诺，然后从不食言。</p>
<h1 id="chapter-2-以终为始-–-自我领导原则"><a href="#chapter-2-以终为始-–-自我领导原则" class="headerlink" title="chapter 2 以终为始 – 自我领导原则"></a>chapter 2 以终为始 – 自我领导原则</h1><p>太多人成功之后，反而感到空虚；得到名利之后，却发现牺牲了更宝贵的东西。因此，我们务必固守真正重要的愿景，然后勇往直前坚持到底，是生活充满意义。</p>
<blockquote><p>和内在力量相比，身外之物显得微不足道。</p>
<footer><strong>David Starr Jordan</strong></footer></blockquote>

<h2 id="“以终为始”的定义"><a href="#“以终为始”的定义" class="headerlink" title="“以终为始”的定义"></a>“以终为始”的定义</h2><p>从现在开始，以你的人生目标作为衡量一切的标准，你的一言一行，一举一动，无论发生在何时，都必须遵守这一原则，即由个人最重视的期许或价值观来决定一切。以终为始说明在做任何事之前，都要先认清方向。</p>
<h2 id="任何事物都需要两次创造"><a href="#任何事物都需要两次创造" class="headerlink" title="任何事物都需要两次创造"></a>任何事物都需要两次创造</h2><p>“以终为始”的一个原则基础是“任何事都是两次创造而成”。我们做任何事都是现在头脑中构思，即智力上的或第一次的创造(Mental&#x2F;First Creation)，然后付诸实践，即体力上的或第二次创造(Physical&#x2F;Second Creation)</p>
<h2 id="主动设计还是被动接受"><a href="#主动设计还是被动接受" class="headerlink" title="主动设计还是被动接受"></a>主动设计还是被动接受</h2><p>自我意识、良知和想象力这些人类的独特天赋让我们能审视各种第一次的创造，并掌握自己的那一部分，即自己撰写自己的剧本。换句话说，习惯一谈的是“你是创造者”，习惯二谈的是“第一次创造”。</p>
<h2 id="领导与管理：两次创造"><a href="#领导与管理：两次创造" class="headerlink" title="领导与管理：两次创造"></a>领导与管理：两次创造</h2><p>领导和管理就好比思想与行为。管理是正确地做事，领导则是做正确的是。管理是有效地顺着成功的梯子往上爬，领导则判断这个梯子是否搭在了正确的墙上。<br>个人生活中的领导意识则更为匮乏，很多人连自己的价值观都没有搞清楚，就忙于提高效率，制定目标或完成任务。</p>
<h2 id="改写人生剧本：成为自己的第一次创造者"><a href="#改写人生剧本：成为自己的第一次创造者" class="headerlink" title="改写人生剧本：成为自己的第一次创造者"></a>改写人生剧本：成为自己的第一次创造者</h2><p>以终为始意味着要到这清晰的方向和价值观来扮演自己的家长角色或其他角色，要为自己人生的第一次创造负责，为改写自己的人生剧本负责，从而使决定行为和态度的思维方式真正符合自己的价值观和正确原则。</p>
<h2 id="个人使命宣言"><a href="#个人使命宣言" class="headerlink" title="个人使命宣言"></a>个人使命宣言</h2><p>以终为始最有效的方法，就是撰写一份个人使命宣言，即人生哲学或基本信念。宣言主要说明自己想成为怎样的人（品德），成就什么样的事业（贡献和成就）及为此奠基的价值观和原则。</p>
<h2 id="核心区"><a href="#核心区" class="headerlink" title="核心区"></a>核心区</h2><p>核心是安全感、人生方向、智慧与力量的源泉。</p>
<ul>
<li>安全感：代表价值观、认同、情感的归属、自尊自重与拥有个人的基本能力。</li>
<li>人生方向：是“地图”和内心的准绳，人类以此为解释外界事物的理据以及决策与行为的原则和内在标准。</li>
<li>智慧：是人类对生命的认知、对平衡的感知和对事物间联系的理解，包括判断力、洞察力和理解力，是这些能力的统一体。</li>
<li>力量：指采取行动、达成目标的能力，它是做出抉择的关键性力量，也包括培育更有效的习惯以代理顽固旧习的能力。</li>
</ul>
<h2 id="各种生活中心"><a href="#各种生活中心" class="headerlink" title="各种生活中心"></a>各种生活中心</h2><p>休太长的假，看太多的电影或电视，打太多的电子游戏，长期无所事事，都等于浪费生命，无益于增长智慧，激发潜能，增进安全感或指引人生，只不过制造更多的<strong>空虚</strong>而已。</p>
<h2 id="以原则为中心"><a href="#以原则为中心" class="headerlink" title="以原则为中心"></a>以原则为中心</h2><h2 id="撰写使命宣言并付诸实践"><a href="#撰写使命宣言并付诸实践" class="headerlink" title="撰写使命宣言并付诸实践"></a>撰写使命宣言并付诸实践</h2><h2 id="唯有参与-才有认同"><a href="#唯有参与-才有认同" class="headerlink" title="唯有参与 才有认同"></a>唯有参与 才有认同</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/08/computer_science/USB%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://srcnn-blog.oss-cn-hangzhou.aliyuncs.com/2023-10-06-15-57-57_0d920927.png">
      <meta itemprop="name" content="srcnn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/08/computer_science/USB%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" class="post-title-link" itemprop="url">USB网络设备驱动</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-08 23:31:57" itemprop="dateCreated datePublished" datetime="2021-07-08T23:31:57+08:00">2021-07-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2021/07/08/computer_science/USB%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2021/07/08/computer_science/USB%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是USB网络设备驱动。"><a href="#什么是USB网络设备驱动。" class="headerlink" title="什么是USB网络设备驱动。"></a>什么是USB网络设备驱动。</h1><h1 id="网络设备驱动"><a href="#网络设备驱动" class="headerlink" title="网络设备驱动"></a>网络设备驱动</h1><h1 id="USB设备驱动"><a href="#USB设备驱动" class="headerlink" title="USB设备驱动"></a>USB设备驱动</h1><!---more--->

<h1 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h1><h1 id="Training-Detail"><a href="#Training-Detail" class="headerlink" title="Training Detail"></a>Training Detail</h1><h1 id="PyTorch-Code"><a href="#PyTorch-Code" class="headerlink" title="PyTorch Code"></a>PyTorch Code</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="">论文地址</a><br><a href="">参考代码</a></p>
<p>网络设备驱动的特点</p>
<ol>
<li>网络设备是通过sk_buff来像上层提交设备的。</li>
<li>在Linux中，整个协议栈都是在内核里的，驱动只是最底下的一层。</li>
</ol>
<p>网络看协议接口层<br>主要功能<br>给上层协议提供统一的数据包收发接口，无论上层是ARP协议还是IP协议，都通过dev_queue_xmit函数发送数据，通过netif_rx函数接收数据。此层使上层协议独立于具体的设备。</p>
<p>为网络驱动提供一系列netif开头的函数<br>激活设备发送队列 netif_start_queue<br>xxxx</p>
<p>网络设备接口层。<br>为千变万化的网络设备定义统一的、抽象的数据结构net_device结构体，以不变应万变，实现多种硬件在软件层面上的统一。</p>
<p>sk_buff以及围绕sk_buff的操作。</p>
<p>.usbdrv.probe = rtw_drv_init<br>rtw_drv_init：USB初始化<br>    rtw_usb_if1_init 初始化网络设备驱动</p>
<p>加载模块后调用的函数名称<br>rtw_drv_entry 入口</p>
<p>// USB驱动的回调函数。<br>struct rtw_usb_drv usb_drv = {<br>    .usbdrv.name =(char*)DRV_NAME,<br>    .usbdrv.probe = rtw_drv_init,<br>    .usbdrv.disconnect = rtw_dev_remove,<br>    .usbdrv.id_table = rtw_usb_id_tbl,<br>    .usbdrv.suspend =  rtw_suspend,<br>    .usbdrv.resume = rtw_resume,<br>    #if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2, 6, 22))<br>      .usbdrv.reset_resume   = rtw_resume,<br>    #endif<br>    #ifdef CONFIG_AUTOSUSPEND<br>    .usbdrv.supports_autosuspend = 1,<br>    #endif</p>
<pre><code>#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2, 6, 19))
.usbdrv.drvwrap.driver.shutdown = rtw_dev_shutdown,
#else
.usbdrv.driver.shutdown = rtw_dev_shutdown,
#endif
</code></pre>
<p>};</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lcokenm/article/details/46572967">https://blog.csdn.net/lcokenm/article/details/46572967</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lcokenm/article/details/46574567?spm=1001.2014.3001.5501">https://blog.csdn.net/lcokenm/article/details/46574567?spm=1001.2014.3001.5501</a></p>
<p>入口函数<br>rtw_drv_entry</p>
<p>wifi相关知识：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Righthek/article/details/39347723?spm=1001.2014.3001.5502">https://blog.csdn.net/Righthek/article/details/39347723?spm=1001.2014.3001.5502</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Righthek/article/details/39994295?spm=1001.2014.3001.5502">https://blog.csdn.net/Righthek/article/details/39994295?spm=1001.2014.3001.5502</a></p>
<p>现在我们可以这样来看，从硬件层面上看，WIFI设备与CPU通信是通过USB接口的，与其他WIFI设备之间的通信是通过无线射频（RF）。从软件层面上看，Linux操作系统要管理WIFI设备，那么就要将WIFI设备挂载到USB总线上，通过USB子系统实现管理。而同时为了对接网络，又将WIFI设备封装成一个网络设备。</p>
<p>我们以USB接口的WIFI模块进行分析：</p>
<p>（1）从USB总线的角度去看，它是USB设备；</p>
<p>（2）从Linux设备的分类上看，它又是网络设备；</p>
<p>（3）从WIFI本身的角度去看，它又有自己独特的功能及属性，因此它又是一个私有的设备；</p>
<p> 1、现在我们先从USB设备开始，要写一个USB设备驱动，那么大致步骤如下：</p>
<p>1）需要针对该设备定义一个USB驱动，对应到代码中即定义一个usb_driver结构体变量。代码如下：<br>struct rtw_usb_drv {<br>    struct usb_driver usbdrv;<br>    int drv_registered;<br>    u8 hw_type;<br>};</p>
<p>struct rtw_usb_drv usb_drv = {<br>    .usbdrv.name =(char*)DRV_NAME,<br>    .usbdrv.probe = rtw_drv_init,<br>    .usbdrv.disconnect = rtw_dev_remove,<br>    .usbdrv.id_table = rtw_usb_id_tbl,<br>    .usbdrv.suspend =  rtw_suspend,<br>    .usbdrv.resume = rtw_resume,<br>    #if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2, 6, 22))<br>      .usbdrv.reset_resume   = rtw_resume,<br>    #endif<br>    #ifdef CONFIG_AUTOSUSPEND<br>    .usbdrv.supports_autosuspend = 1,<br>    #endif</p>
<pre><code>#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2, 6, 19))
.usbdrv.drvwrap.driver.shutdown = rtw_dev_shutdown,
#else
.usbdrv.driver.shutdown = rtw_dev_shutdown,
#endif
</code></pre>
<p>};</p>
<p>2）填充该设备的usb_driver结构体成员变量。代码如下：</p>
<pre><code>             static struct usb_driver xxx_usb_wifi_driver = {

                  .name =             "XXX_USB_WIFI",

                  .probe=   xxx_probe,

                  .disconnect=   xxx_disconnect,

                  .suspend=        xxx_suspend,

                  .resume=         xxx_resume,

                  .id_table=        xxx_table,

             };
</code></pre>
<p>（3）将该驱动注册到USB子系统。代码如下：<br>                  usb_register(&amp;xxx_usb_wifi_driver);</p>
<p>以上步骤只是一个大致的USB驱动框架流程，而最大和最复杂的工作是填充usb_driver结构体成员变量。以上步骤的主要工作是将USB接口的WIFI设备挂载到USB总线上，以便Linux系统在USB总线上就能够找到该设备。</p>
<p>2、接下来是网络设备的线索，网络设备驱动大致步骤如下：</p>
<pre><code>     （1）定义一个net_device结构体变量ndev。代码如下：

                       struct net_device *ndev;
                       		pnetdev = rtw_alloc_etherdev(sizeof(_adapter));

     （2）初始化ndev变量并分配内存。代码如下：

                       ndev=alloc_etherdev();

     （3）填充ndev -&gt; netdev_ops结构体成员变量。代码如下：

     #if (LINUX_VERSION_CODE&gt;=KERNEL_VERSION(2,6,29))
</code></pre>
<p>static const struct net_device_ops rtw_netdev_ops = {<br>    .ndo_init = rtw_ndev_init,<br>    .ndo_uninit = rtw_ndev_uninit,<br>    .ndo_open = netdev_open,<br>    .ndo_stop = netdev_close,<br>    .ndo_start_xmit = rtw_xmit_entry,<br>#if (LINUX_VERSION_CODE&gt;=KERNEL_VERSION(2,6,35))<br>    .ndo_select_queue	= rtw_select_queue,<br>#endif<br>    .ndo_set_mac_address = rtw_net_set_mac_address,<br>    .ndo_get_stats = rtw_net_get_stats,<br>    .ndo_do_ioctl = rtw_ioctl,<br>};<br>#endif</p>
<pre><code>                       static const struct net_device_ops xxx_netdev_ops= {

                                .ndo_init= xxx_ndev_init,

                                .ndo_uninit= xxx _ndev_uninit,

                                .ndo_open= netdev_open,

                                .ndo_stop= netdev_close,

                                .ndo_start_xmit= xxx_xmit_entry,

                                .ndo_set_mac_address= xxx_net_set_mac_address,

                                .ndo_get_stats= xxx_net_get_stats,

                                .ndo_do_ioctl= xxx_ioctl,

                       };

     （4）填充ndev-&gt;wireless_handlers结构体成员变量，该变量是无线扩展功能。代码如下：

                       ndev-&gt;wireless_handlers = (struct iw_handler_def *)&amp;xxx_handlers_def;]
                #ifdef CONFIG_WIRELESS_EXT
</code></pre>
<p>struct iw_handler_def rtw_handlers_def =<br>{<br>    .standard = rtw_handlers,<br>    .num_standard = sizeof(rtw_handlers) / sizeof(iw_handler),<br>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,33)) || defined(CONFIG_WEXT_PRIV)<br>    .private = rtw_private_handler,<br>    .private_args = (struct iw_priv_args *)rtw_private_args,<br>    .num_private = sizeof(rtw_private_handler) / sizeof(iw_handler),<br>     .num_private_args = sizeof(rtw_private_args) / sizeof(struct iw_priv_args),<br>#endif<br>#if WIRELESS_EXT &gt;= 17<br>    .get_wireless_stats = rtw_get_wireless_stats,<br>#endif<br>};<br>#endif</p>
<pre><code>     （5）将ndev设备注册到网络子系统。代码如下：

                        register_netdev(ndev);

     3、WIFI设备本身私有的功能及属性，如自身的配置及初始化、建立与用户空间的交互接口、自身功能的实现等。

     （1）自身的配置及初始化。代码如下：

                       xxx_read_chip_info();

                       xxx_chip_configure();

                       xxx_hal_init();

     （2）主要是在proc和sys文件系统上建立与用户空间的交互接口。代码如下：

                       xxx_drv_proc_init();

                       xxx_ndev_notifier_register();
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Righthek/article/details/44756433?spm=1001.2014.3001.5502">https://blog.csdn.net/Righthek/article/details/44756433?spm=1001.2014.3001.5502</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Righthek/article/details/53906307?spm=1001.2014.3001.5502">https://blog.csdn.net/Righthek/article/details/53906307?spm=1001.2014.3001.5502</a></p>
<p>platform 设备驱动<br>总线将设备和驱动绑定。在系统每注册一个设备的时候，会寻找与之匹配的驱动；</p>
<p>Linux 发明了一种虚拟的总线，成为platform总线，相应的设备成为platform_device, 而驱动成为platform_driver.</p>
<p>Linux，用C语言实现类似C++的多态性。</p>
<ol>
<li>file_operations 的读、写、ioctl都被中间层搞定，各种I/O模型也被处理掉了。</li>
<li>中间层实现通用逻辑。可以被底层各种实例共享的代码都被中间层搞定，避免底层重复实现。</li>
<li>对下定义框架。底层的驱动不再需要关心Linux内核VFS的接口和各种可能的I/O模型，而只需要处理与具体硬件相关的访问。</li>
</ol>
<p>cfg80211：用于对无线设备进行配置管理。cfg80211&amp;nl80211基于消息机制，使用netlink接口。</p>
<p>wiphy：无线网络设备驱动使用cfg80211需要硬件设备在cfg80211中实现注册。实现注册就要定义一系列的硬件功能描述的结构体。每个设备的基础性结构体是wiphy，设备连接到系统是，都要使用。每个wiphy有0个，1个或者许多个虚拟接口相关联。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/141630753">https://zhuanlan.zhihu.com/p/141630753</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/143096580">https://zhuanlan.zhihu.com/p/143096580</a><br>iw&lt;–netlink–&gt;cfg80211&lt;–cfg80211_ops–&gt;mac80211-&gt;调用到驱动注册的代码。</p>
<p>// 很关键的一个函数，通过宏定义提供给驱动调用。<br>ieee80211_alloc_hw_nm</p>
<p>mac80211是linux内核子系统，是驱动开发者可用于为softmac无线设备写驱动的框架。mac80211在内核空间实现STA模式。在用户空间实现AP模式。</p>
<p>mac80211_minstrel_ht 速率控制模块<br>mac80211_netdev_notifier 网络设备注册</p>
<p>如果需要通过WEXT操作wifi的话，需要定义CONFIG_CFG80211_WEXT</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/07/computer_science/%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://srcnn-blog.oss-cn-hangzhou.aliyuncs.com/2023-10-06-15-57-57_0d920927.png">
      <meta itemprop="name" content="srcnn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/07/computer_science/%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">信号安全函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-07 22:49:28" itemprop="dateCreated datePublished" datetime="2021-06-07T22:49:28+08:00">2021-06-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2021/06/07/computer_science/%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2021/06/07/computer_science/%E4%BF%A1%E5%8F%B7%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>天啊，怎么改了几行代码就改出了一个惊天大的大Bug。居然导致死锁了，这是怎么回事呢，且让我一一道来。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hxlawf/article/details/98961011">https://blog.csdn.net/hxlawf/article/details/98961011</a></p>
<!---more--->

<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>我们首先需要知道信号的概念。<strong>信号</strong>就是一条小消息，它通知进程系统中发生一个某种类型的事件。信号提供了某种机制，通知用户进程发生了某些异常。</p>
<p>信号是很短的消息，可以被发送到一个进程或一组进程。信号是事件发生时对进程的通知机制，有时也称之为软件中断。信号与硬件中断的相似之处在于打断了程序执行的正常流程，大多数情况下，无法预测信号到达的精确时间。一般来说，使用sigaction设置信号处理程序，当收到信号时，会调用信号处理器程序，可能会随时打断主程序流程；内核代表进程来调用处理器程序，当处理器返回时，主程序会在处理器打断的位置恢复执行。与 signal()相比， sigaction()系统调用在设置信号处置方面提供了更多控制，且更具灵活性。signal有可移植性的风险，尽量使用sigaction来设置信号处理程序。</p>
<p>20-1的图贴上去。<br>archlinux打印出来的kill -l打印出来的信号</p>
<ol>
<li>SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</li>
<li>SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</li>
<li>SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</li>
<li>SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</li>
<li>SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</li>
<li>SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</li>
<li>SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</li>
<li>SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</li>
<li>SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</li>
<li>SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</li>
<li>SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</li>
<li>SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</li>
<li>SIGRTMAX-1  64) SIGRTMAX</li>
</ol>
<p>1<del>31号为常规信号，同种类型的常规信号并不排队，如果一个常规信号被连续发送多次，那么，只有其中的一个发送到接收进程。。32</del>64为实时信号。实时信号与常规信号有很大不同，因为它们必须排队以便发送的多个信号都能被接收到。前者为标准信号。后者为实时信号。</p>
<p>一般而言，将信号处理函数设计得越简单越好。这将降低引发竞争条件的风险。</p>
<h1 id="信号基本概念"><a href="#信号基本概念" class="headerlink" title="信号基本概念"></a>信号基本概念</h1><h1 id="进程中使用信号"><a href="#进程中使用信号" class="headerlink" title="进程中使用信号"></a>进程中使用信号</h1><h1 id="线程中使用信号。"><a href="#线程中使用信号。" class="headerlink" title="线程中使用信号。"></a>线程中使用信号。</h1><h1 id="如何编写合适的信号处理函数"><a href="#如何编写合适的信号处理函数" class="headerlink" title="如何编写合适的信号处理函数"></a>如何编写合适的信号处理函数</h1><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>死锁风险<br>可重入性问题。</p>
<h2 id="信号术语"><a href="#信号术语" class="headerlink" title="信号术语"></a>信号术语</h2><h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><p>通过kill系统调用发送信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>pid &gt; 0，那么会发送信号给由 pid 指定的进程所属的线程组。</li>
<li>pid = 0，那么会发送信号给与调用进程同组的每个进程，包括调用进程自身。</li>
<li>pid &lt; -1，那么会向组 ID 等于该 pid 绝对值的进程组内所有下属进程发送信号。</li>
<li>pid = -1，调用进程有权将信号发往的每个目标进程，除去swapper(PID 0)，init (PID 1) 和自身进程。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span></span>;</span><br></pre></td></tr></table></figure>
<p>sigqueue系统调用可以发送实时信号。其使用方式同kill，略有不同的是，sigqueue不能通过将pid指定为负值而向整个进程组发送信号。在调用sigaction设置信号处理程序时，可以指定SA_SIGINFO标志位，就能额外收到value数据了。</p>
<h2 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h2><p>当内核把进程p从内核态切换到用户态时(例如系统调用返回，或者完成了一次上下文切换(时间片开始处))，会去检查进程p的所有未被阻塞的待处理信号。(pending &amp; ~blocked)，如果这个集合非空，那么内核选择集合中某个信号k(通常是最小的k)，并且强制p接收k。进程p收到k信号后会有如下几种方式对k信号做出应答。收到这个信号会触发某些操作。如果用sigaction注册了信号处理函数，则执行相关信号处理函数，否则执行信号的默认操作。<br>信号默认操作表。</p>
<ol>
<li>显示地忽略信号。</li>
<li>执行信号的缺省操作。由内核定义，详见表xxxx</li>
<li>通过调用相应的信号处理函数捕获信号。</li>
</ol>
<h2 id="阻塞和解除阻塞"><a href="#阻塞和解除阻塞" class="headerlink" title="阻塞和解除阻塞"></a>阻塞和解除阻塞</h2><p>内核会为每个进程维护一个信号掩码，即一组信号，并将阻塞其针对该进程的传递。如果将遭阻塞的信号发送给某进程，那么对该信号的传递将延后，直至从进程信号掩码中移除该信号，从而解除阻塞为止。</p>
<ol>
<li>阻塞当前正在处理的信号。即，如果当前接收到s信号，正在执行S信号处理函数处理，此时又来了一个s信号，则s会变成待处理没有被接收。</li>
<li>调用sigprocmask及其相关函数，明确地阻塞或解除阻塞信号。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *restrict set, <span class="type">sigset_t</span> *restrict oset)</span></span>; <span class="comment">// </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>; <span class="comment">// 初始化set为空集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>; <span class="comment">// 将每个信号都加到set中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span></span>; <span class="comment">// 将signum信号添加到set中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span></span>; <span class="comment">// 从set中删除signum信号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span></span>; <span class="comment">// 检查signum信号是否在set信号集中。</span></span><br></pre></td></tr></table></figure>

<p>sigprocmask改变当前阻塞的信号集合。取决于<code>how</code>参数的设定。<br>SIG_BLOCK: 将set指向信号集内的指定信号添加到信号掩码中。<br>SIG_UNBLOCK: 将set指向信号集中的信号从信号掩码中移除。即使要解除阻塞的信号当前并未处于阻塞状态，也不会返回错误<br>SIG_SETMASK: 将 set 指向的信号集赋给信号掩码。</p>
<p>如下代码展示如何临时阻塞接收SIGINT</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sigset_t block_set, prev_set;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sigempty</span>(&amp;block_set);</span><br><span class="line"><span class="built_in">sigaddset</span>(&amp;block_set, SIGINT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 阻塞SIGINT，保存先前的信号掩码 */</span></span><br><span class="line"><span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;blcok_set, &amp;prev_set);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此执行代码，不会被SIGINT打断。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复先前的信号掩码 */</span></span><br><span class="line"><span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev_mask, NULL);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/258885880">https://zhuanlan.zhihu.com/p/258885880</a></p>
<h1 id="编写信号处理程序"><a href="#编写信号处理程序" class="headerlink" title="编写信号处理程序"></a>编写信号处理程序</h1><p>信号处理是Linux系统编程最棘手的一个问题。处理程序又几个属性使得它们很难推理分析：</p>
<ul>
<li>处理程序与主程序并发运行，共享同样的全局变量。因此可能与主程序和其他信号处理程序互相干扰</li>
<li>如何以及何时接收信号的规则常常有违人的直觉</li>
<li>不同的系统有不同的信号处理语义</li>
</ul>
<p>图8-31.<br>信号处理程序很麻烦的是因为他们和主程序以及其他信号处理程序并发的执行。如果这些程序都需要访问修改同样的全局变量。将导致不可预知的结果。</p>
<p>《深入理解计算机系统》提出了安全的编写信号处理程序的几个建议：</p>
<ol>
<li>处理程序要尽可能简单。例如，信号处理程序只设置全局标志位并立即返回。</li>
<li>在主程序只调用异步信号安全函数。异步信号安全函数是指那些可重入函数或者不能被信号中断的函数。</li>
<li>保存和恢复errno。许多Linux异步信号安全函数都会在返回时设置errno。在信号处理程序中调用这样的函数会干扰主程序中其他依赖errno的部分。</li>
<li>阻塞所有信号，保护对共享全局数据结构的访问。</li>
<li>用volatile生命全局变量。volatile强制编译器每次在代码中引用被其修饰的变量时都要从内存重新读取。</li>
<li>用sig_atomic_t生命标志。C语言提供整型数据类型sig_atomic_t，对它的读写保证是原子性的。</li>
</ol>
<p>eg： libevent中的信号处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __cdecl</span></span><br><span class="line"><span class="function"><span class="title">evsig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 保存错误码</span></span><br><span class="line">    <span class="type">int</span> save_errno = errno;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="type">int</span> socket_errno = <span class="built_in">EVUTIL_SOCKET_ERROR</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">ev_uint8_t</span> msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (evsig_base == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">event_warnx</span>(</span><br><span class="line">            <span class="string">"%s: received signal %d, but have no base configured"</span>,</span><br><span class="line">            __func__, sig);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EVENT__HAVE_SIGACTION</span></span><br><span class="line">    <span class="built_in">signal</span>(sig, evsig_handler);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wake up our notification mechanism */</span></span><br><span class="line">    msg = sig;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">send</span>(evsig_base_fd, (<span class="type">char</span>*)&amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    {</span><br><span class="line">    <span class="comment">// 向读端fd，写入一个字节信号值。write是信号安全函数。</span></span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">write</span>(evsig_base_fd, (<span class="type">char</span>*)&amp;msg, <span class="number">1</span>);</span><br><span class="line">        (<span class="type">void</span>)r; <span class="comment">/* Suppress 'unused return value' and 'unused var' */</span></span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    errno = save_errno;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">EVUTIL_SET_SOCKET_ERROR</span>(socket_errno);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>libevent的信号处理程序遵守了1，2，3规则。信号处理程序很简单，仅仅往一个文件描述符中写入一个字节数据。只调用write信号安全函数，避免调用一些非信号安全的函数。因为write系统调用可能会改变errno，因此保存回复了errno的值。</p>
<p>信号处理时只是记录了下产生了什么信号,并没有进行实际处理,处理过程还是交给主程序本身,避免调用一些非信号安全的函数。因此我们再编写信号处理函数的时候也只要记录下信号状态，对errno这种全局变量，进行保存，处理结束后恢复变量值，尽量避免使用锁。</p>
<p>注：</p>
<ol>
<li>创建一个管道(Libevent实际上使用的是socketpair)</li>
<li>为这个socketpair的一个读端创建一个event，并将之加入到多路IO复用函数的监听之中</li>
<li>设置信号捕抓函数</li>
<li>有信号发生，就往socketpair写入一个字节<br>这里只展示libevent如何处理信号，需更深入了解libevent对信号的处理，可参考如下博客，或libevent源码。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/luotuo44/article/details/38538991">https://blog.csdn.net/luotuo44/article/details/38538991</a></li>
</ol>
<p>程序。<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ourroad/p/4834383.html">https://www.cnblogs.com/ourroad/p/4834383.html</a><br>如图8-31.<br>主程序收到s信号。执行s信号处理程序S。在S执行过程中，收到t信号，t信号终端S程序，转而执行T信号处理程序。T返回时，S从它被中断的地方继续执行。最后S返回，主程序从被中断的地方继续执行。</p>
<p>操作系统内核使用一种成为上下文切换的较高层形式的异常控制流来实现多任务。内核为每个进程维持一个上下文。上下文就是内核重新启动一个被抢占进程所需的状态。<br>上下文切换：1. 保存当前进程的上下文。2. 回复某个先前被抢占的进程被保存的上下文。3. 将控制权传递给这个回复的进程。</p>
<h1 id="多线程程序中使用信号"><a href="#多线程程序中使用信号" class="headerlink" title="多线程程序中使用信号"></a>多线程程序中使用信号</h1><p>本来编写信号处理程序就很难了，多线程程序本身也很难，多线程+信号简直是强人锁男，男上加男嘛。应该尽量避免将两者结合起来使用，不然写出了Bug，就只能一言难尽了。</p>
<h1 id="POSIX信号和多线程应用"><a href="#POSIX信号和多线程应用" class="headerlink" title="POSIX信号和多线程应用"></a>POSIX信号和多线程应用</h1><p>POSIX 1003.1标准对多线程应用的信号处理有一些严格的要求：</p>
<ul>
<li><strong>信号处理程序必须在多线程应用的所有线程之间共享</strong>；不过，每个线程必须有自己的挂起信号掩码和阻塞掩码</li>
<li>POSIX库函数<strong>kill()<strong>和</strong>sigqueue()<strong>必须向</strong>所有</strong>的多线程应用而不是某个特殊的线程发送信号。所有由内核产生的信号同样如此(如：SIGCHLD、SIGINT或SIGQUIT)</li>
<li>每个发送给多线程应用的信号仅传递给一个线程，这个线程是由内核在从<strong>不会阻塞该信号的线程</strong>中随意选择出来的。</li>
<li>如果向多线程应用发送了一个致命的信号，那么内核将<strong>杀死该应用的所有线程</strong>，而不仅仅是杀死接收信号的那个线程。</li>
</ul>
<p>如果一个挂起的信号发送给了某个特定的进程，那么这个信号就是私有的；如果被发送给了整个线程组，它就是共享的。<br>每种信号类型对应一个元素，Linux中可以声明的信号的最大数是64。没有值为0的信号，因此，信号的编号对应于sigset_t类型变量中的相应位下标加1</p>
<h1 id="给指定线程发送信号"><a href="#给指定线程发送信号" class="headerlink" title="给指定线程发送信号"></a>给指定线程发送信号</h1><ol>
<li>pthread_kill类似kill，但pthread_kill给<strong>指定的线程</strong>发送信号。kill会给所有的线程发送信号。</li>
<li>pthread_sigqueue类似sigqueue，但pthread_sigqueue给<strong>指定的线程</strong>发送实时信号。sigqueue会给所有的线程发送实时信号。</li>
</ol>
<p>将信号发给指定线程和发给线程组有很大不同。信号发送给指定线程，由<strong>指定线程</strong>调用信号处理程序对其进行处理；信号发给线程组，且该线程组已然为此信号创建了信号处理程序时，内核会<strong>任选一条线程来接收</strong>这一信号，并在<strong>该线程</strong>中调用信号处理程序对其进行处理。</p>
<h1 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h1><p>发送给进程一个信号，这个信号可能来自内核，也可能来自另一个进程。内核通过表所示的某个函数进行调用而产生信号。最后都会调用specific_send_sig_info函数。</p>
<p>当一个信号被发往整个线程组时，这个信号可能来自内核，也可能来自另一个进程。最终都调用group_send_sig_info函数。<br>__group_complete_signal 扫描线程组中的进程，查找能接收新信号的进程。满足以下条件可能被选中。<br>每当从内核态向用户态转换时，内核态堆栈都被清空。</p>
<p>系统调用重新执行。系统调用执行到一半时接收到一个信号，去执行信号处理函数。</p>
<h1 id="发送信号-1"><a href="#发送信号-1" class="headerlink" title="发送信号"></a>发送信号</h1><h1 id="案例分析–localtime-r导致的死锁问题。"><a href="#案例分析–localtime-r导致的死锁问题。" class="headerlink" title="案例分析–localtime_r导致的死锁问题。"></a>案例分析–localtime_r导致的死锁问题。</h1><p>这里分析由我的一个提交引入的死锁问题。</p>
<p>localtime_r是线程安全函数，但不是信号安全函数。进程A执行过程中使用localtime_r，信号处理程序也调用了localtime_r函数localtime_r会调用到tz_convert上锁。如果进程A调用localtime_r已经上锁了，此时进程A收到信号去执行信号处理函数，信号处理函数也调用localtime_r，就会导致死锁发生。<br>如下程序模拟了在信号处理程序中调用localtime_r导致的死锁问题。主线程创建子线程和发送信号线程，注册信号处理程序，在信号处理程序中调用localtime_r函数。子线程处理函数中频繁调用localtime_r。发送信号线程每隔1s给指定线程id的线程发送信号。<br>从实验的结果来看：</p>
<ol>
<li>给子线程发送信号会导致死锁。</li>
<li>给主线程和发送信号线程发送信号不会导致死锁。<br>原因在于，子线程处理程序频繁调用localtime_r函数。信号处理函数也调用localtime_r函数。当子线程处理函数调用localtime_r上锁后还没来得及释放锁，此时收到信号。执行信号处理程序又调用localtime_r请求上锁。从而导致死锁。<br>而主线程和发送信号线程由于没有调用localtime_r，因而给主线程和信号发送线程发送信号不会导致死锁。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">tm</span> *</span><br><span class="line"><span class="built_in">localtime_r</span> (<span class="type">const</span> <span class="type">time_t</span> *t, <span class="keyword">struct</span> tm *tp)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tm</span> *l = <span class="built_in">localtime</span> (t);</span><br><span class="line">  <span class="keyword">if</span> (! l)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  *tp = *l;</span><br><span class="line">  <span class="keyword">return</span> tp;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> *</span><br><span class="line">__localtime64_r (<span class="type">const</span> <span class="type">__time64_t</span> *t, <span class="keyword">struct</span> tm *tp)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">return</span> __tz_convert (*t, <span class="number">1</span>, tp);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>pthread_kill发出的信号，只有该线程收到信号并处理。<br>如果<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/coding-my-life/p/4782529.html">https://www.cnblogs.com/coding-my-life/p/4782529.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34067049/article/details/87957176">https://blog.csdn.net/weixin_34067049/article/details/87957176</a></p>
<h1 id="非信号安全函数带来的风险。死锁风险分析"><a href="#非信号安全函数带来的风险。死锁风险分析" class="headerlink" title="非信号安全函数带来的风险。死锁风险分析"></a>非信号安全函数带来的风险。死锁风险分析</h1><p>死锁概念以及如何避免死锁，已有博客说明，这里不再详细说明。<br>localtime_r带来的死锁风险。<br>测试代码：注：该程序运行在Linux archlinux 5.10.43-1-lts 中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> g_main_thread_id;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> g_sub_thread_id;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> g_send_sig_thread_id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sig_handler</span><span class="params">(<span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">time_t</span> time_s = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> now_time;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 信号处理程序调用localtime_r非信号安全函数。</span></span><br><span class="line">    <span class="built_in">localtime_r</span>(&amp;time_s, &amp;now_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get signum %d, the thread_id is %lu\n"</span>, signum, <span class="built_in">pthread_self</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">send_sig_func</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 发送给main线程处理，不会导致死锁。</span></span><br><span class="line">        <span class="comment">// pthread_kill(g_main_thread_id, SIGUSR1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送给send_sig线程，不会导致死锁。</span></span><br><span class="line">        <span class="comment">// pthread_kill(g_send_sig_thread_id, SIGUSR1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送给子线程处理，会导致死锁。子线程处理函数和信号处理都调用了localtime_r</span></span><br><span class="line">        <span class="built_in">pthread_kill</span>(g_sub_thread_id, SIGUSR1);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">call_localtime_r</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">time_t</span> time_s = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> now_time;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">localtime_r</span>(&amp;time_s, &amp;now_time);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">    <span class="type">sigset_t</span> block_set;</span><br><span class="line"></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = sig_handler;</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGUSR1, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取主线程的线程id */</span></span><br><span class="line">    g_main_thread_id = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"g_main_thread_id = %lu\n"</span>, g_main_thread_id);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;g_sub_thread_id, <span class="literal">NULL</span>, call_localtime_r, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"g_sub_thread_id = %lu\n"</span>, g_sub_thread_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送信号线程 */</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;g_send_sig_thread_id, <span class="literal">NULL</span>, send_sig_func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"g_send_sig_thread_id = %lu\n"</span>, g_send_sig_thread_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注意，省略了错误检查 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(g_sub_thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(g_send_sig_thread_id, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>打印</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(gdb) thread apply all bt</span><br><span class="line"></span><br><span class="line">Thread <span class="number">3</span> (Thread <span class="number">0</span>x7fcb80b84640 (LWP <span class="number">3602</span>) <span class="string">"a.out"</span>): <span class="comment">// g_send_sig_thread_id</span></span><br><span class="line">#<span class="number">0</span>  <span class="number">0</span>x00007fcb8144fa95 in clock_nanosleep@GLIBC_2.<span class="number">2.5</span> () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0</span>x00007fcb81454c77 in nanosleep () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0</span>x00007fcb81454bae in sleep () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">3</span>  <span class="number">0</span>x000055c310a54276 in send_sig_func () at test_localtime_r.c:<span class="number">42</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0</span>x00007fcb8155e259 in start_thread () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libpthread.so.<span class="number">0</span></span><br><span class="line">#<span class="number">5</span>  <span class="number">0</span>x00007fcb814875e3 in clone () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line"></span><br><span class="line">Thread <span class="number">2</span> (Thread <span class="number">0</span>x7fcb81385640 (LWP <span class="number">3601</span>) <span class="string">"a.out"</span>): <span class="comment">// g_sub_thread_id</span></span><br><span class="line">#<span class="number">0</span>  <span class="number">0</span>x00007fcb8140e0ab in __lll_lock_wait_private () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0</span>x00007fcb81445fb1 in __tz_convert () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0</span>x000055c310a54214 in sig_handler (signum=<span class="number">10</span>) at test_localtime_r.c:<span class="number">25</span></span><br><span class="line">#<span class="number">3</span>  &lt;signal handler called&gt;</span><br><span class="line">#<span class="number">4</span>  <span class="number">0</span>x00007fcb81445940 in __tzset_parse_tz () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">5</span>  <span class="number">0</span>x00007fcb81447403 in __tzfile_compute () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">6</span>  <span class="number">0</span>x00007fcb81445e66 in __tz_convert () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">7</span>  <span class="number">0</span>x000055c310a542b4 in call_localtime_r () at test_localtime_r.c:<span class="number">52</span></span><br><span class="line">#<span class="number">8</span>  <span class="number">0</span>x00007fcb8155e259 in start_thread () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libpthread.so.<span class="number">0</span></span><br><span class="line">#<span class="number">9</span>  <span class="number">0</span>x00007fcb814875e3 in clone () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libc.so.<span class="number">6</span></span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> (Thread <span class="number">0</span>x7fcb81386740 (LWP <span class="number">3600</span>) <span class="string">"a.out"</span>): <span class="comment">// g_main_thread_id</span></span><br><span class="line">#<span class="number">0</span>  <span class="number">0</span>x00007fcb8156a8ca in __futex_abstimed_wait_common64 () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libpthread.so.<span class="number">0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0</span>x00007fcb8155f743 in __pthread_clockjoin_ex () <span class="keyword">from</span> <span class="regexp">/usr/</span>lib/libpthread.so.<span class="number">0</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0</span>x000055c310a543d1 in main () at test_localtime_r.c:<span class="number">79</span></span><br></pre></td></tr></table></figure>

<p>glibc中tz_convet代码<br>struct tm *<br>__tz_convert (__time64_t timer, int use_localtime, struct tm *tp)<br>{<br>  long int leap_correction;<br>  int leap_extra_secs;</p>
<p>  __libc_lock_lock (tzset_lock);</p>
<p>  /* Update internal database according to current TZ setting.<br>     POSIX.1 8.3.7.2 says that localtime_r is not required to set tzname.<br>     This is a good idea since this allows at least a bit more parallelism.  */<br>  tzset_internal (tp == &amp;_tmbuf &amp;&amp; use_localtime);</p>
<p>  if (__use_tzfile)<br>    __tzfile_compute (timer, use_localtime, &amp;leap_correction,<br>              &amp;leap_extra_secs, tp);<br>  else<br>    {<br>      if (! __offtime (timer, 0, tp))<br>    tp = NULL;<br>      else<br>    __tz_compute (timer, tp, use_localtime);<br>      leap_correction = 0L;<br>      leap_extra_secs = 0;<br>    }</p>
<p>  __libc_lock_unlock (tzset_lock);</p>
<p>  if (tp)<br>    {<br>      if (! use_localtime)<br>    {<br>      tp-&gt;tm_isdst = 0;<br>      tp-&gt;tm_zone = “GMT”;<br>      tp-&gt;tm_gmtoff = 0L;<br>    }</p>
<pre><code>  if (__offtime (timer, tp-&gt;tm_gmtoff - leap_correction, tp))
    tp-&gt;tm_sec += leap_extra_secs;
  else
tp = NULL;
}
</code></pre>
<p>  return tp;<br>}</p>
<p>从以上分析就能知道为什么我这个提交会导致死锁了。这个提交，将pthread_kill改成了sigqueue。<br>原本是由xxxx线程执行信号处理程序。变成内核会<strong>任选一条线程来接收</strong>这一信号。main线程没有阻塞xxx信号。很有可能学到main程序来执行信号处理程序。main程序本身也有调用localtime_r，信号处理程序也调用localtime_r。这样就导致了死锁。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>不知道哪位名人说过：未经反省的人生是不值得过的。由于写了一个Bug，因而写了这边博客反省一下。博文若有不正确的地方还请各位同事指出，让我在反省反省~</p>
<h1 id="PyTorch-Code"><a href="#PyTorch-Code" class="headerlink" title="PyTorch Code"></a>PyTorch Code</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="">论文地址</a><br><a href="">参考代码</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/26/computer_science/Linux-kernel-module/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://srcnn-blog.oss-cn-hangzhou.aliyuncs.com/2023-10-06-15-57-57_0d920927.png">
      <meta itemprop="name" content="srcnn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/26/computer_science/Linux-kernel-module/" class="post-title-link" itemprop="url">Linux kernel module</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-26 23:26:54" itemprop="dateCreated datePublished" datetime="2021-05-26T23:26:54+08:00">2021-05-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2021/05/26/computer_science/Linux-kernel-module/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2021/05/26/computer_science/Linux-kernel-module/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>762</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是内核模块"><a href="#什么是内核模块" class="headerlink" title="什么是内核模块"></a>什么是内核模块</h1><p>内核模块是可以根据需要加载和卸载到内核中的代码片段。它们扩展了内核的功能，而无需重新启动系统。例如，一种类型的内核模块是设备驱动程序，它允许内核访问连接到系统的硬件(例如nvmp中GPIO驱动电机就编译成了内核模块，在比如wifi驱动)。如果没有内核模块，我们将不得不构建庞大的内核，并将新功能直接添加到内核image中。除了拥有更大的内核外，这还有一个缺点，即每次需要新功能时都需要重新构建和重新启动内核。</p>
<!---more--->

<h1 id="模块加载进内核的方法"><a href="#模块加载进内核的方法" class="headerlink" title="模块加载进内核的方法"></a>模块加载进内核的方法</h1><ul>
<li>通过使用<code>insmod xxx.ko</code>可将模块加载进内核。</li>
<li>通过<code>modprobe xxx</code>加载模块。<br>两者不同的是，insmod要求传递完整的路径名并按正确的顺序插入模块，而modprobe只接受名称，没有任何扩展名，并通过解析<code>/lib/modules/version/modules.dep</code>找出模块的依赖关系</li>
</ul>
<h1 id="从hello-world出发构建最简单的模块"><a href="#从hello-world出发构建最简单的模块" class="headerlink" title="从hello world出发构建最简单的模块"></a>从hello world出发构建最简单的模块</h1><p>以下代码是一个最简单的内核模块。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">hello_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">printk</span>(KERN_INFO <span class="string">"Hello, world!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">printk</span>(KERN_INFO <span class="string">"Goodbye, world!\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(hello_init);</span><br><span class="line"><span class="built_in">module_exit</span>(hello_exit);</span><br></pre></td></tr></table></figure>

<h1 id="Training-Detail"><a href="#Training-Detail" class="headerlink" title="Training Detail"></a>Training Detail</h1><h1 id="PyTorch-Code"><a href="#PyTorch-Code" class="headerlink" title="PyTorch Code"></a>PyTorch Code</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="">论文地址</a><br><a href="">参考代码</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/19/computer_science/Static-Link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://srcnn-blog.oss-cn-hangzhou.aliyuncs.com/2023-10-06-15-57-57_0d920927.png">
      <meta itemprop="name" content="srcnn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/19/computer_science/Static-Link/" class="post-title-link" itemprop="url">Static Link</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-19 23:46:56" itemprop="dateCreated datePublished" datetime="2021-04-19T23:46:56+08:00">2021-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2021/04/19/computer_science/Static-Link/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2021/04/19/computer_science/Static-Link/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在日常的开发中很多时候都会遇到链接问题。比如，缺少模块、缺少库或者库版本不兼容导致的链接问题；错误定义多个全局变量导致程序运行产生不可预知的错误。为了减少这些错误的发生，我们应当理解链接过程。本文主要讨论静态链接。</p>
<!---more--->

<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>接下来主要通过下面简单的例子来介绍静态链接。</p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main.c:</span><br><span class="line"><span class="type">int</span> <span class="built_in">sum</span>(<span class="type">int</span> *a, <span class="type">int</span> n);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="built_in">sum</span>(<span class="type">array</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sum</span>.c</span><br><span class="line"><span class="built_in">int</span> <span class="keyword">sum</span>(<span class="built_in">int</span> *a, <span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i, s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用gcc命令将上述两文件编译成可执行程序。</p>
<p>我们使用最简单的例子来学习静态链接。main函数初始化一个int形的array数组。然后调用sum函数计算array个各元素的和。</p>
<h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><p>为了构造可执行文件，链接器必须完成两个主要任务</p>
<ol>
<li>符号解析。一个函数，全局变量或者静态变量可以是一个符号，局部变量在栈空间分配，不是一个符号。符号解析的目的是将每个符号引用正好一个符号定义关联起来。</li>
<li>重定位。编译器和链接器生成以地址0开始的代码段和数据段。这些地址并不是程序执行时的真正地址，因此需要通过链接器修正所有符号的引用，使它们的地址为程序执行时的真正地址。</li>
</ol>
<h1 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h1><p>目标文件有三种形式</p>
<ul>
<li>可重定位文件。包含代码和数据，可以被用来链接成可执行文件或共享目标文件。</li>
<li>可执行文件。可直接复制到内存并执行。</li>
<li>共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</li>
</ul>
<h1 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h1><p>目标文件将代码，数据，符号表，调试信息等不同属性的信息，以段的形式存储。一个目标文件中有多个段。</p>
<ul>
<li>ELF头。可以使用readelf命令查看ELF文件头信息。ELF文件头定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量等。</li>
<li>.text。已编译程序的机器代码</li>
<li>.rodata。只读数据，例如printf语句中的格式化输出字符串。</li>
<li>.data。已初始化的全局和静态变量。</li>
<li>.bss。未初始化或初始化为0的全局和静态变量。未初始化变量不占用任何磁盘空间。运行是，在内存分配这些变量，初始值为0</li>
<li>.symtab。符号表，存放程序中定义和引用的函数和全局变量的信息。</li>
<li>.rel.text。代码段重定位表。根据其中存储的符号offset值可以计算出符号正确地址，</li>
<li>.rel.data。数据段重定位表。</li>
<li>.strtab。字符串表。保存字符串，符号的名字，段名等。</li>
</ul>
<h1 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h1><p>每个目标文件都有一个相应的符号表，这个表记录了目标文件定义和引用的所有符号。一般有三种不同的符号：</p>
<ul>
<li>定义在本目标文件的全局符号，可被其他目标文件使用。对应在本目标文件中定义的非static的函数和全局变量。</li>
<li>定义在其他目标文件，在本目标文件中引用的全局变量。对应在其他目标文件定义的非static的函数和全局变量。</li>
<li>在本目标文件定义和引用的局部符号。对应static修饰的函数或变量。</li>
</ul>
<h2 id="符号表的结构"><a href="#符号表的结构" class="headerlink" title="符号表的结构"></a>符号表的结构</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>	st_name; <span class="comment">/* string table offset */</span></span><br><span class="line">    <span class="type">char</span> type:<span class="number">4</span>, <span class="comment">/* Function or data (4bits) */</span></span><br><span class="line">         bingding:<span class="number">4</span>;  <span class="comment">/* Local or global (4bits) */</span></span><br><span class="line">    <span class="type">char</span> reserved;  <span class="comment">/* unused */</span></span><br><span class="line">    <span class="type">short</span>	section; <span class="comment">/* section header index */</span></span><br><span class="line">    <span class="type">long</span>	value; <span class="comment">/* section offset or absolute address */</span></span><br><span class="line">    <span class="type">long</span>	size;  <span class="comment">/* object size in bytes */</span></span><br><span class="line">&#125; Elf64_Sym; </span><br></pre></td></tr></table></figure>
<ul>
<li>name。字符串表的偏移量。</li>
<li>type。符号类型</li>
<li>binding。符号是本地的还是全局的。</li>
<li>section。到段表(section header)的索引</li>
<li>value。表示偏移量或者绝对地址。</li>
<li>size。符号的大小。<br>可以使用readelf工具分析上文提到的例子的目标文件。<br><code>readelf -s main.o</code>可以得到以下输出：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Num:    <span class="keyword">Value</span>          Size <span class="keyword">Type</span>    Bind   Vis      Ndx <span class="type">Name</span></span><br><span class="line">  <span class="number">0</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  <span class="keyword">LOCAL</span>  <span class="keyword">DEFAULT</span>  UND </span><br><span class="line">  <span class="number">1</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> FILE    <span class="keyword">LOCAL</span>  <span class="keyword">DEFAULT</span>  ABS main.c</span><br><span class="line">  <span class="number">2</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> SECTION <span class="keyword">LOCAL</span>  <span class="keyword">DEFAULT</span>    <span class="number">1</span> </span><br><span class="line">  <span class="number">3</span>: <span class="number">0000000000000000</span>     <span class="number">8</span> <span class="keyword">OBJECT</span>  <span class="keyword">GLOBAL</span> <span class="keyword">DEFAULT</span>    <span class="number">3</span> <span class="keyword">array</span></span><br><span class="line">  <span class="number">4</span>: <span class="number">0000000000000000</span>    <span class="number">33</span> FUNC    <span class="keyword">GLOBAL</span> <span class="keyword">DEFAULT</span>    <span class="number">1</span> main</span><br><span class="line">  <span class="number">5</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  <span class="keyword">GLOBAL</span> <span class="keyword">DEFAULT</span>  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">  <span class="number">6</span>: <span class="number">0000000000000000</span>     <span class="number">0</span> NOTYPE  <span class="keyword">GLOBAL</span> <span class="keyword">DEFAULT</span>  UND sum</span><br></pre></td></tr></table></figure>
可以得知符号main是一个位于.text段偏移量为0的33字节函数。array是一个位于.data段的偏移量为0的8字节符号。</li>
</ul>
<h1 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h1><h2 id="解析多重定义的全局符号"><a href="#解析多重定义的全局符号" class="headerlink" title="解析多重定义的全局符号"></a>解析多重定义的全局符号</h2><p>函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。针对强弱符号的概念，linux链接器使用如下规则处理多重定义的符号名</p>
<ul>
<li>规则1: 不允许强符号被多次定义</li>
<li>规则2: 如果一个强符号和多个弱符号同名，那么选择强符号。</li>
<li>规则3: 如果有多个弱符号同名，那么从这些弱符号中任意选择一个。(程序员自我修养中说到是选择占用空间最大的符号。)</li>
</ul>
<ol>
<li><p>example 1</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>符号a是一个强符号，被定义了两次。编译这段程序会提示：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test.c:<span class="number">2</span>:<span class="number">5</span>: error: redefinition of ‘a’</span><br><span class="line">    <span class="number">2</span> <span class="string">| int a = 1;</span></span><br><span class="line">      <span class="string">|     ^</span></span><br><span class="line">test.c:<span class="number">1</span>:<span class="number">5</span>: note: previous definition of ‘a’ was here</span><br><span class="line">    <span class="number">1</span> <span class="string">| int a = 0;</span></span><br><span class="line">      <span class="string">|     ^</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>example 2:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* func.c */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="number">20000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>gcc -o main test.c func.c &amp;&amp; ./main</code>应该打印<code>x = 20000</code><br>然而，实际上在我的电脑测试并不能成功通过编译。gcc版本是10.2.0。经查证，gcc 10.0以上的版本编译默认从-fcommon转到-fno-common.-fno-common选项告诉链接器，遇到重定义符号，就触发一个错误。</p>
<p>使用<code>gcc -o main test.c func.c -fcommon &amp;&amp; ./main</code>打印<code>x = 20000</code>。</p>
<ol start="3">
<li>example3<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">20000</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = 0x%x y = 0x%x \n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* func.c */</span></span><br><span class="line"><span class="type">double</span> x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="number">-0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>使用<code>gcc -o main test.c func.c -fcommon &amp;&amp; ./main</code>,编译过程只会产生一条警告信息<code>/usr/bin/ld: warning: alignment 4 of symbol x in /tmp/cc9XEYKu.o is smaller than 8 in /tmp/ccTc5xbh.o</code>输出<code>x=0x0 y = 80000000</code>(double数-0.0的二进制表示是0x80000000)。<br>这是一个微小的错误，但有时难以发现，可能在程序运行很久之后才表现出来。我们应该如何避免呢？</p>
<ul>
<li>使用全局变量时就将其初始化，使之成为一个强符号。</li>
<li>gcc编译的时候使用-fno-common选项</li>
<li>gcc编译使用-Werror选项，将所有警告都变成错误</li>
</ul>
<h1 id="静态库的链接顺序"><a href="#静态库的链接顺序" class="headerlink" title="静态库的链接顺序"></a>静态库的链接顺序</h1><p>静态库链接时候需要满足一定的顺序，有时改变某两个静态库的顺序就不能链接成功了。在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和静态库。<strong>在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能解析，链接会失败</strong></p>
<p>例如，可以重新编译上述的example2。使用下列命令将func.c编译成func.a静态库。</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="keyword">c</span> -fcommon func.<span class="keyword">c</span></span><br><span class="line">gcc -<span class="keyword">c</span> -fcommon test.<span class="keyword">c</span></span><br><span class="line">ar rcs libfunc.a func.o</span><br></pre></td></tr></table></figure>
<p>使用下列命令可以成功编译。<br>gcc -static -o main test.o .&#x2F;libfunc.a<br>而使用<br>gcc -static -o main .&#x2F;libfunc.a test.o<br>则编译不通过，提示找不到符号</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: test.o: <span class="keyword">in</span> <span class="keyword">function</span> `main<span class="comment">&#x27;:</span></span><br><span class="line">test.c:(.<span class="keyword">text</span>+<span class="number">0</span>x5): undefined reference <span class="keyword">to</span> `func<span class="comment">&#x27;</span></span><br><span class="line"><span class="symbol">collect2:</span> <span class="keyword">error</span>: ld returned <span class="number">1</span> <span class="keyword">exit</span> status</span><br></pre></td></tr></table></figure>
<p>在命令行命令编译过程中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接就会失败。因此尤其需要考虑库的位置。必须确保对符号的引用出现在该符号定义之前。</p>
<h1 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h1><p>编译器遇到对最终位置未知的目标引用，它就会产生一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中。已初始化数据的重定位条目放在.rel.data中。下面结构体展示了重定位条目的格式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> offset;    <span class="comment">/* offset of the referenct to relocate */</span></span><br><span class="line">    <span class="type">long</span> type:<span class="number">32</span>,   <span class="comment">/* relocation type */</span></span><br><span class="line">         symbol:<span class="number">32</span>; <span class="comment">/* Symbol table index */</span></span><br><span class="line">    <span class="type">long</span> addend;    <span class="comment">/* constant part of relocation expression */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>offset。需要被修改的引用的节偏移。</li>
<li>type。重定位类型，这里只讨论R_X86_64_PC32(相对地址引用)和R_X86_64_32(绝对地址引用)两种。</li>
<li>symbol。被修改引用应该指向的符号。</li>
<li>addend。相对地址引用中需要使用该值对被修改引用的值做位置偏移。<br>下面对本文最开始提到的main.o做重定位。使用<code>objdump -d main.o</code>查看反汇编代码。<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0000000000000000</span> &lt;main&gt;:</span><br><span class="line">   <span class="attribute">0</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">   <span class="attribute">1</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">   <span class="attribute">4</span>:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0</span>x10,%rsp</span><br><span class="line">   <span class="attribute">8</span>:   be <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0</span>x2,%esi</span><br><span class="line">   <span class="attribute">d</span>:   <span class="number">48</span> <span class="number">8</span>d <span class="number">3</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0</span>x0(%rip),%rdi        # <span class="number">14</span> &lt;main+<span class="number">0</span>x14&gt;</span><br><span class="line">  <span class="attribute">14</span>:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">19</span> &lt;main+<span class="number">0</span>x19&gt;</span><br><span class="line">  <span class="attribute">19</span>:   <span class="number">89</span> <span class="number">45</span> fc                mov    %eax,-<span class="number">0</span>x4(%rbp)</span><br><span class="line">  <span class="attribute">1c</span>:   <span class="number">8</span>b <span class="number">45</span> fc                mov    -<span class="number">0</span>x4(%rbp),%eax</span><br><span class="line">  <span class="attribute">1f</span>:   c9                      leave  </span><br><span class="line">  <span class="attribute">20</span>:   c3                      ret     </span><br></pre></td></tr></table></figure>
对sum地址的引用为相对引用。相应的重定位条目r由4个字段组成:<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">r.offset</span> = <span class="number">0</span>xf</span><br><span class="line"><span class="attr">r.symbol</span> = sum</span><br><span class="line"><span class="attr">r.type</span> = R_X<span class="number">86_64_</span>PC32</span><br><span class="line"><span class="attr">r.addend</span> = -<span class="number">4</span></span><br></pre></td></tr></table></figure>
现在假定编译器链接完之后，sum符号的地址是0x000000000000113a，main符号的地址是0x0000000000001119。那么如何根据这两个地址计算出sum引用的地址呢？<br>在调用call是，PC的值为call指令之后的指令地址，也就是0x0000000000001119 + 13 &#x3D; 0x0000000000001132<br>也就是说0x0000000000001132 + x &#x3D; 0x000000000000113a, 计算得到x为8。如下所示：<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000001119</span> &lt;main&gt;:</span><br><span class="line">    <span class="number">1119</span>:       <span class="number">55</span>                      push   <span class="variable">%rbp</span></span><br><span class="line">    <span class="number">111</span>a:       <span class="number">48</span> <span class="number">89</span> e<span class="number">5</span>                mov    <span class="variable">%rsp</span><span class="punctuation">,</span><span class="variable">%rbp</span></span><br><span class="line">    <span class="number">111</span>d:       <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             <span class="keyword">sub</span>    $<span class="number">0x10</span><span class="punctuation">,</span><span class="variable">%rsp</span></span><br><span class="line">    <span class="number">1121</span>:       be <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x2</span><span class="punctuation">,</span><span class="variable">%esi</span></span><br><span class="line">    <span class="number">1126</span>:       <span class="number">48</span> <span class="number">8</span>d <span class="number">3</span>d fb <span class="number">2</span>e <span class="number">00</span> <span class="number">00</span>    lea    <span class="number">0x2efb</span>(<span class="variable">%rip</span>)<span class="punctuation">,</span><span class="variable">%rdi</span>        # <span class="number">4028</span> &lt;array&gt;</span><br><span class="line">    <span class="number">112</span>d:       e<span class="number">8</span> <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">call</span>   <span class="number">113</span>a &lt;sum&gt;</span><br><span class="line">    <span class="number">1132</span>:       <span class="number">89</span> <span class="number">45</span> fc                mov    <span class="variable">%eax</span><span class="punctuation">,</span><span class="number">-0</span><span class="keyword">x</span><span class="number">4</span>(<span class="variable">%rbp</span>)</span><br><span class="line">    <span class="number">1135</span>:       <span class="number">8</span>b <span class="number">45</span> fc                mov    <span class="number">-0</span><span class="keyword">x</span><span class="number">4</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span><span class="variable">%eax</span></span><br><span class="line">    <span class="number">1138</span>:       <span class="keyword">c</span><span class="number">9</span>                      leave  </span><br><span class="line">    <span class="number">1139</span>:       <span class="keyword">c</span><span class="number">3</span>                      <span class="keyword">ret</span>    </span><br><span class="line"></span><br><span class="line"><span class="number">000000000000113</span>a &lt;sum&gt;:</span><br><span class="line">    <span class="number">113</span>a:       <span class="number">55</span>                      push   <span class="variable">%rbp</span></span><br><span class="line">    <span class="number">113</span>b:       <span class="number">48</span> <span class="number">89</span> e<span class="number">5</span>                mov    <span class="variable">%rsp</span><span class="punctuation">,</span><span class="variable">%rbp</span></span><br><span class="line">    <span class="number">113</span>e:       <span class="number">48</span> <span class="number">89</span> <span class="number">7</span>d e<span class="number">8</span>             mov    <span class="variable">%rdi</span><span class="punctuation">,</span><span class="number">-0</span><span class="keyword">x</span><span class="number">18</span>(<span class="variable">%rbp</span>)</span><br><span class="line">    <span class="number">1142</span>:       <span class="number">89</span> <span class="number">75</span> e<span class="number">4</span>                mov    <span class="variable">%esi</span><span class="punctuation">,</span><span class="number">-0</span><span class="keyword">x</span><span class="number">1</span><span class="keyword">c</span>(<span class="variable">%rbp</span>)</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文简单介绍了静态链接。大量参考了《程序员的自我修养》和《深入理解计算机系统》这两本书。参考这两本书可以对静态链接有更深入的理解。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/03/computer_science/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://srcnn-blog.oss-cn-hangzhou.aliyuncs.com/2023-10-06-15-57-57_0d920927.png">
      <meta itemprop="name" content="srcnn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/03/computer_science/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">Redis 整数集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-03 11:12:04" itemprop="dateCreated datePublished" datetime="2020-06-03T11:12:04+08:00">2020-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2020/06/03/computer_science/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2020/06/03/computer_science/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h1><p>整数集合(intset)是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为<br>int16_t、int32_t、int64_t的整数值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> {</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 元素的个数</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">} intset;</span><br></pre></td></tr></table></figure>
<!---more--->
<ul>
<li>encoding:保存整数集合的类型<ul>
<li>INTSETi_ENCi_INT16:保存数据类型是int16_t</li>
<li>INTSETi_ENCi_INT32:保存数据类型是int32_t</li>
<li>INTSETi_ENCi_INT64:保存数据类型是int64_t</li>
</ul>
</li>
<li>length: 保存长度信息</li>
<li>contents:保存所有的元素</li>
</ul>
<h1 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h1><p>当我们插入的数据比现有的所有数据都要长的时候需要进行数据的升级。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> intset *<span class="title function_">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="type">int64_t</span> value)</span> {</span><br><span class="line">    <span class="type">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    <span class="type">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="type">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    <span class="type">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First set new encoding and resize */</span></span><br><span class="line">    <span class="comment">// 设置encoding 并resize +1 表示需要添加的元素</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade back-to-front so we don't overwrite values.</span></span><br><span class="line"><span class="comment">     * Note that the "prepend" variable is used to make sure we have an empty</span></span><br><span class="line"><span class="comment">     * space at either the beginning or the end of the intset. */</span></span><br><span class="line">    <span class="comment">// 将原先数据移动到合适的位置</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></span><br><span class="line">    <span class="comment">// 引发升级操作 要么小于所有的数，要么大于所有的数</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        <span class="comment">// 数据是负的，太小引发升级操作</span></span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 数据是正数，太大引发升级操作</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<ul>
<li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间</li>
<li>将底层数组现有的所有元素转化成与新元素相同的类型，并放置在合适的位置上，</li>
<li>将新元素添加到合适的位置，头或尾</li>
</ul>
<h1 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h1><ul>
<li>提升灵活性</li>
<li>节约内存</li>
</ul>
<h1 id="整数集合API"><a href="#整数集合API" class="headerlink" title="整数集合API"></a>整数集合API</h1><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>*intsetNew(void)</td>
<td>创建一个新的压缩列表</td>
</tr>
<tr>
<td>*intsetAdd(intset *is, int64_t value, uint8_t *success)</td>
<td>将给定元素添加到整数集合里面</td>
</tr>
<tr>
<td>*intsetRemove(intset *is, int64_t value, int *success)</td>
<td>从整数集合移除给定元素</td>
</tr>
<tr>
<td>intsetFind(intset *is, int64_t value)</td>
<td>检查给定值是否存在在集合</td>
</tr>
<tr>
<td>intsetRandom(intset *is)</td>
<td>从整数集合中随机返回一个元素</td>
</tr>
<tr>
<td>intsetGet(intset *is, uint32_t pos, int64_t *value)</td>
<td>取出底层数组在给定索引上的元素</td>
</tr>
<tr>
<td>intsetLen(const intset *is)</td>
<td>返回整数集合包含的严肃个数</td>
</tr>
<tr>
<td>intsetBlobLen(intset *is)</td>
<td>返回整数集合占用的内存字节数</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/02/computer_science/Redis-ziplist/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://srcnn-blog.oss-cn-hangzhou.aliyuncs.com/2023-10-06-15-57-57_0d920927.png">
      <meta itemprop="name" content="srcnn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SRCNN">
      <meta itemprop="description" content="computer science">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SRCNN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/02/computer_science/Redis-ziplist/" class="post-title-link" itemprop="url">Redis ziplist</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-02 23:36:46" itemprop="dateCreated datePublished" datetime="2020-06-02T23:36:46+08:00">2020-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-17 23:16:20" itemprop="dateModified" datetime="2023-09-17T23:16:20+08:00">2023-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2020/06/02/computer_science/Redis-ziplist/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2020/06/02/computer_science/Redis-ziplist/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry1&gt;....&lt;entryn&gt;&lt;zlend&gt;</span><br></pre></td></tr></table></figure>
<p>上述展示了一个压缩列表的构成</p>
<ul>
<li>zlbytes:uint32_t，4字节，记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，或者计算zlend的位置时使用</li>
<li>zltail:uint32_t，4字节，记录压缩列表最后一个entry的offset。</li>
<li>zllen:uint16_t，2字节，记录压缩列表entry的个数，当值大于INT16i_MAX时，需要遍历整个压缩列表才能计算得到长度</li>
<li>entry:列表节点，</li>
<li>zlend:uint6_t，1字节，0xFF，标记压缩列表的末端<!---more---></li>
</ul>
<h1 id="压缩列表的节点"><a href="#压缩列表的节点" class="headerlink" title="压缩列表的节点"></a>压缩列表的节点</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>prevlen:记录上一个entry的长度，用于从尾向前移动<ul>
<li>如果前一个entry的长度小于254字节，那么prelen属性的长度为1个字节</li>
<li>入股前一个entry的长度大于254字节，那么prelen属性的长度为5个字节，其中第一个字节设置为0xFE，而之后的四个字节用于保存前一个节点的长度。</li>
</ul>
</li>
<li>encoding:记录entry的内容的属性和长度<ul>
<li>|00pppppp| encoding长度为一个字节，pppppp代表entry-data的长度，小于63个字节的字符串数据，字符串数据</li>
<li>|01pppppp|qqqqqqqq| encoding长度为两个字节，ppppppqqqqqqqq表示entry-data的长度，小于16383个字节的字符串数据</li>
<li>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| encoding长度为五个字节，q-t表示entry的长度，小于<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.816ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 3012.6 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>字节的字符串数据</li>
<li>|11000000| encoding长度为一个字节，encoding+entry-data为3个字节 整型数据 int16_t(2 bytes)</li>
<li>|11010000| encoding长度为一个字节，encoding+entry-data为5个字节整型数据 int32_t(4 bytes)</li>
<li>|11100000| encoding长度为一个字节，encoding+entry-data为9个字节整型数据 int64_t(8 bytes)</li>
<li>|11110000| encoding长度为一个字节，encoding+entry-data为4个字节整型数据 24bit带符号整型数据(3 bytes)</li>
<li>|11111110| encoding长度为一个字节，encoding+entry-data为2个字节整型数据 8bit带符号整型数据(1 bytes)</li>
<li>|1111xxxx| xxxx 在0001-1101(1-13)之间的数据, 计算的时候要减1(0-12).</li>
<li>|11111111| 0xFF结束标识符</li>
</ul>
</li>
<li>entry-data: 根据encoding决定存储的数据类型和长度。str 或 int</li>
</ul>
<h1 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h1><p>当插入一个entry时，因为每个entry的头部都要用一个字节或者五个字节记录上一个entry的长度<br>所以插入一个entry后，需要更新后面所有entry的prevlen，最坏情况是之后所有entry的prevlen的<br>长度都由一个字节变为五个字节。</p>
<ul>
<li>需要逐个entry更新到最后一个</li>
<li>需要收缩长度的地方，为了提高效率，我们不进行收缩，而使用5个字节表示原先用1个字节就能表示的长度<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *__ziplistCascadeUpdate(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> *p) {</span><br><span class="line">    <span class="type">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;</span><br><span class="line">    <span class="type">size_t</span> offset, noffset, extra;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *np;</span><br><span class="line">    zlentry cur, next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END) {</span><br><span class="line">        <span class="comment">// 得到当前entry</span></span><br><span class="line">        zipEntry(p, &amp;cur);</span><br><span class="line">        <span class="comment">// 当前entry的总长度</span></span><br><span class="line">        rawlen = cur.headersize + cur.len;</span><br><span class="line">        <span class="comment">// 需要用几个字节来存储当前entry的总长度，&lt;254 1 个字节， 大于254 5个字节</span></span><br><span class="line">        rawlensize = zipStorePrevEntryLength(<span class="literal">NULL</span>,rawlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Abort if there is no next entry. */</span></span><br><span class="line">        <span class="comment">// 如果p已经是最后一个entry了</span></span><br><span class="line">        <span class="keyword">if</span> (p[rawlen] == ZIP_END) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 得到下一个entry的地址</span></span><br><span class="line">        zipEntry(p+rawlen, &amp;next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Abort when "prevlen" has not changed. */</span></span><br><span class="line">        <span class="comment">// 如果下一个entry的prelen已经是正确的不需要做任何操作</span></span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlen == rawlen) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下一个entry需要用5个字节来替换1个字节存储，扩容</span></span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlensize &lt; rawlensize) {</span><br><span class="line">            <span class="comment">/* The "prevlen" field of "next" needs more bytes to hold</span></span><br><span class="line"><span class="comment">             * the raw length of "cur". */</span></span><br><span class="line">            offset = p-zl;</span><br><span class="line">            <span class="comment">// 需要增加的字节的大小</span></span><br><span class="line">            extra = rawlensize-next.prevrawlensize;</span><br><span class="line">            <span class="comment">// 重新resize</span></span><br><span class="line">            zl = ziplistResize(zl,curlen+extra);</span><br><span class="line">            p = zl+offset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Current pointer and offset for next element. */</span></span><br><span class="line">            <span class="comment">// 下一个指针地址</span></span><br><span class="line">            np = p+rawlen;</span><br><span class="line">            <span class="comment">// 下一个指针的offset</span></span><br><span class="line">            noffset = np-zl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update tail offset when next element is not the tail element. */</span></span><br><span class="line">            <span class="comment">// 改变&lt;zoffset&gt;</span></span><br><span class="line">            <span class="keyword">if</span> ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) {</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move the tail to the back. */</span></span><br><span class="line">            <span class="comment">//  需要扩张，把后面内存的东西搬到前面来</span></span><br><span class="line">            memmove(np+rawlensize,</span><br><span class="line">                np+next.prevrawlensize,</span><br><span class="line">                curlen-noffset-next.prevrawlensize<span class="number">-1</span>); </span><br><span class="line">            zipStorePrevEntryLength(np,rawlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Advance the cursor */</span></span><br><span class="line">            <span class="comment">// 指向下一个节点来继续更新操作</span></span><br><span class="line">            p += rawlen;</span><br><span class="line">            <span class="comment">// 更新当前的ziplist的长度</span></span><br><span class="line">            curlen += extra;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (next.prevrawlensize &gt; rawlensize) {</span><br><span class="line">                <span class="comment">/* This would result in shrinking, which we want to avoid.</span></span><br><span class="line"><span class="comment">                 * So, set "rawlen" in the available bytes. */</span></span><br><span class="line">                <span class="comment">// 可能会导致收缩，但是我们不做收缩 收缩效率降低</span></span><br><span class="line">                <span class="comment">// 我们此时用5个字节来表示原先1个字节就可以存储的长度</span></span><br><span class="line">                zipStorePrevEntryLengthLarge(p+rawlen,rawlen);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                zipStorePrevEntryLength(p+rawlen,rawlen);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Stop here, as the raw length of "next" has not changed. */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="压缩列表API"><a href="#压缩列表API" class="headerlink" title="压缩列表API"></a>压缩列表API</h1><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>*ziplistNew(void)</td>
<td>创建一个新的压缩列表</td>
</tr>
<tr>
<td>*ziplistMerge(unsigned char **first, unsigned char **second)</td>
<td>合并两个压缩列表</td>
</tr>
<tr>
<td>*ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where)</td>
<td>创建一个列表，添加到表头或表尾</td>
</tr>
<tr>
<td>*ziplistIndex(unsigned char *zl, int index)</td>
<td>返回压缩列表索引上的节点</td>
</tr>
<tr>
<td>*ziplistNext(unsigned char *zl, unsigned char *p)</td>
<td>得到压缩列表下一个节点</td>
</tr>
<tr>
<td>*ziplistPrev(unsigned char *zl, unsigned char *p)</td>
<td>得到压缩列表上一个节点</td>
</tr>
<tr>
<td>ziplistGet(unsigned char *p, unsigned char **sval, unsigned int *slen, long long *lval)</td>
<td>获取给定接待呢所保存的值</td>
</tr>
<tr>
<td>*ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen)</td>
<td>插入一个节点</td>
</tr>
<tr>
<td>*ziplistDelete(unsigned char *zl, unsigned char **p)</td>
<td>删除一个节点</td>
</tr>
<tr>
<td>*ziplistDeleteRange(unsigned char *zl, int index, unsigned int num)</td>
<td>删除一个范围的节点</td>
</tr>
<tr>
<td>*ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip)</td>
<td>在压缩列表中查找并返回包含了给定值的节点</td>
</tr>
<tr>
<td>ziplistLen(unsigned char *zl)</td>
<td>返回压缩列表包含节点的数量</td>
</tr>
<tr>
<td>ziplistBlobLen(unsigned char *zl)</td>
<td>返回压缩列表目前占用的字节数</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2020 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">srcnn@cs</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">217k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:01</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://waline.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"libUrl":"https://unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/page/2/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
